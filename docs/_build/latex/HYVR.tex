% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{HYVR Documentation}
\date{Jan 03, 2018}
\release{0.1}
\author{Jeremy Bennett}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Welcome to the Hydrogeological Virtual Reality (HyVR) simulation package.

Contents:


\chapter{Introduction}
\label{intro::doc}\label{intro:the-hydrogeological-virtual-reality-hyvr-simulation-package}\label{intro:introduction}
\textbf{HyVR: Turn your geofantasy into reality!}

The Hydrogeological Virtual Reality simulation package (HyVR) is a Python module that helps researchers and practitioners generate subsurface models with multiple scales of heterogeneity that are based on geological concepts. The simulation outputs can then be used to explore groundwater flow and solute transport behaviour. This is facilitated by HyVR outputs in common flow-and-transport simulation input formats. As each site is unique, HyVR has been designed that users can take the code and extend it to suit their particular simulation needs.

The original motivation for HyVR was the lack of tools for modelling sedimentary deposits that include bedding structure model outputs (i.e. dip and azimuth). Such bedding parameters were required to approximate full hydraulic-conductivity tensors for groundwater flow and solute transport modelling. HyVR is able to simulate these bedding parameters and generate spatially distributed parameter fields, including full hydraulic-conductivity tensors.

I hope you enjoy using HyVR much more than I enjoyed putting it together! I look forward to seeing what kind of funky fields you created in the course of your work.


\section{Installing the HYVR package (Windows)}
\label{intro:installing-the-hyvr-package-windows}

\subsection{With conda}
\label{intro:with-conda}
To install HyVR we recommend first installing the \href{https://www.anaconda.com/download/}{Anaconda distribution} of Python 3. This distribution has the majority of dependencies that HyVR requires.

It is a good idea to install the HyVR package into a \href{https://conda.io/docs/user-guide/tasks/manage-environments.html}{virtual environment}. Do this by opening a command prompt window and typing the following:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{virtualenv} \PYG{n}{hyvr\PYGZus{}env}
\end{Verbatim}

You need to then activate this environment:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{call} \PYG{n}{hyvr\PYGZus{}env}\PYG{o}{/}\PYG{n}{scripts}\PYG{o}{/}\PYG{n}{activate}
\end{Verbatim}

Install the necessary python packages by downloading the \sphinxcode{requirements.txt} file in the HyVR repository and then running:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{n}{path} \PYG{n}{to}\PYG{o}{\PYGZgt{}}\PYG{n}{requirements}\PYG{o}{.}\PYG{n}{txt}
\end{Verbatim}

Once this is completed install HyVR using pip:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{hyvr\PYGZus{}env}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{n}{working} \PYG{n}{directory}\PYG{o}{\PYGZgt{}} \PYG{n}{pip} \PYG{n}{install} \PYG{n}{hyvr}
\end{Verbatim}

You can test whether HyVR is working by running the default parameters in the Python console:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{hyvr}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{hyvr}\PYG{o}{.}\PYG{n}{sim}\PYG{o}{.}\PYG{n}{main}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}

A number of messages should then be displayed in the console, including the location where the simulation outputs have been saved.


\section{Source}
\label{intro:source}
The most current version of HyVR will be available at the \href{https://github.com/driftingtides/hyvr/}{github repository}; a version will also be available on the \href{https://pypi.python.org/pypi/hyvr/}{PyPI index} which can be installed using \sphinxcode{pip}.


\section{Requirements}
\label{intro:requirements}

\subsection{Python}
\label{intro:python}
HyVR was developed for use with Python 3.4 or greater. It may be possible to use with earlier versions of Python 3, howver this has not been tested.


\subsection{Modules}
\label{intro:modules}\begin{itemize}
\item {} 
scipy

\item {} 
\href{https://pypi.python.org/pypi/PyEVTK}{pyevtk}

\item {} 
pandas

\item {} 
numpy

\item {} 
matplotlib

\item {} 
\href{https://github.com/modflowpy/flopy}{flopy}

\end{itemize}


\section{Development}
\label{intro:development}
You can contact the developer(s) of HyVR by \href{mailto:hyvr.sim@gmail.com}{email}.  HyVR is currently being developed by Jeremy Bennett (\href{https://jeremypaulbennett.weebly.com}{website}) as part of his doctoral research at the University of Tübingen.


\chapter{HYVR Computational methods}
\label{methods::doc}\label{methods:hyvr-computational-methods}
The first step in the HyVR algorithm is to load the model parameters, as defined in the \sphinxcode{*.ini} initialisation file. Sequence contact surfaces are generated first. Architectural element assemblage contact surfaces are then simulated within each sequence, either based on input parameters or loaded from a user-defined lookup table of mean contact surface depths. The external and internal geometries of architectural elements and associated hydrofacies are then simulated within each architectural element assemblage. Internal heterogeneity of the features is simulated at the end.

\emph{Note that in this section model input parameters are denoted in the following manner:} \sphinxcode{parameter-section.parameter}.


\section{Simulation of sequence and architectural element unit contact surfaces}
\label{methods:simulation-of-sequence-and-architectural-element-unit-contact-surfaces}
Sequences are defined in the parameter file by their upper mean elevations and the architectural elements that are to be included within them. The upper contact surface is then generated and all model cells between the lower and upper contact surface are assigned to the sequence.

Contact surfaces can either be flat or random. Multi-Gaussian random contact surfaces are generated using the spectral methods outlined by \phantomsection\label{methods:id1}{\hyperref[references:dietrich1993]{\sphinxcrossref{{[}DN93{]}}}}.  These methods require structural statistical parameters (i.e. mean and variance) for the quantity of interest, and a geostatistical covariance model. We used a Gaussian covariance model in the present study:

\(R_{ss}(h)=\sigma^2_s \exp\left[ - \left[ \frac{\Delta x}{\lambda}\right]^2 \right]\)

where \(s\) is the random quantity of interest, \(\sigma^2_s\) is the variance of \(s\), \(\Delta x\) is the distance between the two points, and \(\lambda\) is the correlation length.

Simulation at the architectural element hierarchical level begins once all sequence units have been assigned. Units in which AEs will be simulated are defined using an architectural element lookup table with the following information:

\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline

Architectural element identifier
&
Mean bottom elevation
&
Mean top elevation
&
Architectural element type
&
Sequence identifier
\\
\hline\end{tabulary}


If the architectural element lookup table is not defined before initializing the simulation, then the architectural element units will be simulated based on input parameters defined for each sequence. This starts with the random choice of an architectural element from those defined; the probability of each architectural element being chosen is also defined in the model parameter file. The thickness of the architectural element unit is then drawn from a random normal distribution that is defined for each sequence in the parameter file. To account for the erosive nature of many sedimentary environments the algorithm may erode the underlying units: here the `avulsion' thickness \(th_{avulsion}\) is subtracted from the bottom and top of the architectural element unit \(z^{bot}_{AE}, z^{top}_{AE}\). Once the architectural element lookup table has been defined, unit contact surfaces are generated using the same procedure as used for sequence contact surfaces. When the architectural element units have been generated, the algorithm begins to simulate external architectural element geometries and hydrofacies.


\section{Simulation of architectural elements and hydrofacies geometries}
\label{methods:simulation-of-architectural-elements-and-hydrofacies-geometries}
The generation of architectural elements and internal hydrofacies occurs sequence- and architectural-element-wise, beginning with the lowest architectural element unit in the lowest sequence. The simulation of individual architectural elements is object-based, with random placement of features within the architectural element units. Object-based methods have been implemented widely in subsurface simulation \phantomsection\label{methods:id2}{\hyperref[references:jussel1994]{\sphinxcrossref{{[}JSD94{]}}}}\phantomsection\label{methods:id3}{\hyperref[references:bennett2017]{\sphinxcrossref{{[}BHC17{]}}}} as they are generally computationally efficient and relatively easy to parameterize. The HyVR program approximates architectural elements with simple geometric shapes. Currently, three {\hyperref[methods:shapes]{\sphinxcrossref{shapes}}} are supported: truncated ellipsoids, channels, and sheets. Truncated ellipsoids and channels are `erosive' architectural elements: this means that within the HyVR algorithm they are able to erode underlying units, and therefore the architectural element (and sequence) boundaries may be altered during the course of the simulation.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{hyvr_geometries}.png}
\caption{\emph{Geometries implemented in HyVR.}}\label{methods:shapes}\label{methods:id11}\end{figure}

Four properties are assigned to each model grid cell during this simulation step: material, facies, azimuth, and dip. The material property is a unique identifier for each individual architectural element generated. The facies property denotes which hydrofacies has been assigned to a model grid cell. The azimuth \(\kappa\) and dip \(\psi\) properties are associated with the bedding structure at each model grid cell and denote the angle of the bedding plane from the mean direction of flow and horizontal, respectively.


\subsection{Truncated ellipsoids}
\label{methods:truncated-ellipsoids}\begin{description}
\item[{Truncated ellipsoids are generated as a proxy for trough-like features. The method for generating the boundaries of these features has been described previously in \phantomsection\label{methods:id4}{\hyperref[references:bennett2017]{\sphinxcrossref{{[}BHC17{]}}}}. Generation starts at \(z^{bot}_{AE unit} +AE_{depth}\cdot\beta\) where \(\beta\) is a buffer term that allows the user to control how much of the underlying unit is eroded. The center of the truncated ellipsoid (\(x,y\) coordinates) and the paleoflow angle \(\alpha\) (i.e. major ellipsoid axis orientation) are drawn from a random uniform distribution and the boundary of the truncated ellipsoid is simulated. The {\hyperref[methods:internal\string-structure]{\sphinxcrossref{internal structure}}} of truncated ellipsoids can be defined in the following ways:}] \leavevmode\begin{itemize}
\item {} 
trough-wise homogeneous, with constant azimuth and dip;

\item {} 
bulb-type, with azimuth and dip values based on the three-dimensional gradient at the ellipsoid boundary;

\item {} 
nested-bulb-like, comprising nested alternating hydrofacies with \(\kappa\) and \(\psi\) values generated as for bulb-type;

\item {} 
dip-set internal structure, where the features have a constant \(\kappa\) and \(\psi\) but the assigned hydrofacies alternate throughout the truncated ellipsoid.

\end{itemize}

\end{description}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{hyvr_ellipsoids}.png}
\caption{\emph{Internal structure of truncated ellipsoid architectural elements.}}\label{methods:structure}\label{methods:id12}\end{figure}


\subsubsection{Bulbs}
\label{methods:bulbs}
Bulb internal heterogeneity is simulated by calculating the three-dimensional gradient at the boundary of the truncated ellipsoid and then the angle between the gradient and a horizontal plane. This angle is then compared with a `maximum dip angle' (\sphinxcode{r\_dip}) and the smaller of these two values is assigned to all model grid cells within the architectural element with equivalent \(x,y\)-coordinates (i.e. column-wise).


\subsubsection{Nested bulbs}
\label{methods:nested-bulbs}
Nested-bulb-like layers are simulated by subdividing the depth of the truncated ellipsoid into a series with a set thickness \sphinxcode{trunc\_ellip.bulbset\_d}. Truncated ellipsoids are simulated consecutively with the same center point and paleoflow \(\alpha\) value, starting with the deepest element. With each simulation, a scaling factor is calculated by dividing the new depth with the total depth of the element. This scaling factor is applied to the length and width parameters of the truncated ellipsoid. Each newly generated ellipsoid subsumes the previous. Each nested element represents a constant hydrofacies, however the orientation of these hydrofacies may differ within the entire architectural element, to create bulb-like features that have been reported in the field. The dip of the nested ellipsoids defaults to that determined by the three-dimension gradient at the nested-ellipsoid boundary.


\subsubsection{Dipset}
\label{methods:dipset}
Refer to \_Dipset section.

Once a truncated ellipsoid has been generated, an aggradation thickness (\sphinxcode{trunc\_ellip.agg}) is added to the current simulation elevation \(z_{sim}\) and the next element is simulated. This occurs until \(z_{sim} = z^{top}_{AE}\).


\subsection{Channels}
\label{methods:channels}
Channels are sinuous features that are in-filled with sediment. Channel centerlines in HyVR are parameterized using the disturbed periodic model implemented by \phantomsection\label{methods:id5}{\hyperref[references:ferguson1976]{\sphinxcrossref{{[}Fer76{]}}}}:

\(\theta + \frac{2h}{k} \frac{d\theta}{ds} + \frac{1}{k^2} \frac{d^2\theta}{ds^2}  = \epsilon(s)\)

with channel direction \(\theta\), damping factor \(h \in [0,1]\), \(k = 2\pi/\lambda\) is the wavenumber with \(\lambda\) the frequency of the undamped sine wave, and \(s\) is the distance along the channel. This model can be approximated using the following second-order autoregressive model described in Equation 15 of \phantomsection\label{methods:id6}{\hyperref[references:ferguson1976]{\sphinxcrossref{{[}Fer76{]}}}} (this method was also used by {[}Pyrcz2009{]} for the simulation of alluvial depositional features). Model grid cells are assigned to the channel if the following conditions are met:

\(D^2 \leqslant \frac{w^2_{ch}}{4} - \left[ \frac{(z_{ch} - z_{cell})\cdot\Delta z \cdot w_{ch}}{d_{ch}} \right] ^2 \; \wedge \; z_{cell} \leqslant z_{ch}\)

where \(D^2\) is the two-dimensional (\(x,y\)) distance from the cell to the channel centerline, \(w_{ch}\) and \(d_{ch}\) are the channel width and depth respectively, \(z_{ch}\) and \(z_{cell}\) are the elevations of the channel top and node respectively, and \(\Delta z\) is the model grid cell \(z\) dimension. Two-dimensional channel velocities \(\vec{v}\) are evaluated at the centerline and then interpolated to grid cells using an inverse-distance-weighted interpolation. Azimuth values are calculated by taking the arctangent of the two-dimensional channel velocity at a given point. Dip values of grid cells within the channel are assigned based on input parameters. If alternating hydrofacies are to be simulated they are constructed by creating planes that are evenly spaced along the channel centerline.

The HyVR algorithm generates channels starting from \(z^{bot}_{AE unit} +AE_{depth}\cdot\beta\), as for truncated ellipsoids. However, to account for the multiple channels that are often concurrently present in many river systems, multiple channels can be generated at each simulation depth (\sphinxcode{channel.channel\_no}). The starting \(x,y\) coordinates for the centerlines are drawn from a random uniform distribution such that \(x\in[-50,0]\) and \(y\in[0,Y]\). Channel geometries are then assigned sequentially to the model grid cells; note that in HyVR there is no interaction of channels, and subsequent channels will supersede (or `erode') those previously generated.  Once the predefined number of channels stipulated by \sphinxcode{channel.channel\_no} has been simulated a three-dimensional migration vector \sphinxcode{channel.r\_mig} is added to the channel centerlines and the channel assignment to model grid cells begins again. The reuse of the channel centerline trajectories is more efficient than re-simulating these values at each \(z_{sim}\). This continues until  \(z_{sim} = z^{top}_{seq}\).


\subsection{Sheets}
\label{methods:sheets}
Sheets are comparatively simple to generate as they are laterally continuous across the entire model domain (depending on sequence boundaries). The internal structure of sheet features may be massive (i.e. without internal structure), or laminations can be generated.  In the HyVR algorithm laminations are simulated sequentially by assigning all model grid cells between a specific elevation interval the appropriate hydrofacies codes. Dipping set structures can also be incorporated into these features. Sheets may differ in orientation, as specified in the input parameters.


\subsection{Internal structure}
\label{methods:internal-structure}
The internal structure of the architectural elements is distinguished by hydrofacies. The internal structure of an architectural element may be homogeneous, dipping or elliptic (for truncated ellipsoid only). Additionally, lag surfaces composed of different hydrofacies may be simulated in erosive (i.e. channel, truncated ellipsoid) architectural elements.


\subsubsection{Dipset}
\label{methods:id8}\phantomsection\label{methods:id9}
Architectural elements may be populated with dipping hydrofacies structures label\{para:dipsets\}. Such structures are generated by creating planes at regular intervals throughout the architectural element, as defined by \sphinxcode{element.dipset\_d}. In truncated ellipsoids the planes are constructed along the centerline of the element, perpendicular to the paleoflow angle \(\alpha\). In channel elements, the planes are constructed along the centerline and are perpendicular to \(\vec{v}(x)\). The distance from the centre of each model grid cell to all planes is calculated and then the model grid cells between planes are assigned a hydrofacies value.


\subsubsection{Lag surfaces}
\label{methods:lag-surfaces}\begin{description}
\item[{Lag surfaces can be set for erosive architectutral elements by setting the \sphinxcode{element.l\_lag} parameter. This parameter consists of two values:}] \leavevmode\begin{itemize}
\item {} 
The thickness of the lag surface from the element base; and

\item {} 
The hydrofacies identifier to be assigned.

\end{itemize}

\end{description}

Lag surfaces cannot have any internal dipping structure.

Sedimentary deposits can often exhibit cyclicity in their features; therefore, HyVR allows alternating hydrofacies to be simulated. This is controlled by sequentially assigning hydrofacies within each architectural element, starting with a hydrofacies randomly selected from those to be simulated in the architectural element (\sphinxcode{element.l\_facies}). The hydrofacies which is assigned next is drawn from a subset of hydrofacies specified in the \sphinxcode{element.ll\_altfacies} input parameter. For each hydrofacies in \sphinxcode{element.l\_facies}, a list of alternating hydrofacies (i.e. which hydrofacies can follow the present one) is stipulated. By only specifying one hydrofacies ID in the \sphinxcode{element.ll\_altfacies}, it guarantees that that ID will be selected. The figure below gives three examples of different input parameters.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.550\linewidth]{{altfac}.png}
\caption{\emph{Variations on alternating hydrofacies in architectural elements}}\label{methods:altfac}\label{methods:id13}\end{figure}


\subsection{Linear trends}
\label{methods:linear-trends}
The HyVR algorithm  allows for linear trends in geometry sizes with increasing elevation by setting the \sphinxcode{element.r\_geo\_ztrend} parameter. This parameter comprises a bottom and top factor that multiply the usual geometry dimensions. For intermediate elevations the \(z\) factor is calculated through a linear interpolation of the top and bottom \(z\) factors. The parameters of each geometry may be set for each individual architectural element included in the model parameter file.


\section{Simulation of hydraulic parameters}
\label{methods:simulation-of-hydraulic-parameters}
Hydraulic parameters are simulated once all features have been generated. The distributed hydraulic parameter outputs of HyVR are: the isotropic hydraulic conductivity \(K_{iso}(x,y,z)\); porosity \(\theta(x,y,z)\); and the full hydraulic conductivity tensor \(\textbf{K}(x,y,z)\), defined for each model grid cell.

Internal heterogeneity of hydraulic parameters is first simulated for each individual architectural element (as present in the \sphinxcode{mat} storage array)  simulated in the previous steps. Spatially varying \(\ln(K_{iso})\) and \(\theta\) fields are generated for each hydrofacies present in an architectural element using spectral methods to simulate random multi-Gaussian fields with an exponential covariance model:

\(R_{ss}(h)=\sigma^2_s \exp\left[ - \left| \frac{\Delta x}{\lambda}\right| \right]\)

An anisotropic ratio is also assigned to each model grid cell according to the hydrofacies present; these ratios are globally constant for each hydrofacies.

Internal heterogeneity may also be assigned to model grid cells that are not within architectural elements. This background heterogeneity is simulated for each architectural element unit using values defined for each architectural element type (\sphinxcode{element.r\_bg}). Simulation methods are the same as for within-element heterogeneity.

Once isotropic hydraulic-conductivity values have been assigned to all model grid cells then spatial trends may also be applied. As for trends in architectural element geometry, \(K_0\) trends are assigned using a linearly-interpolated factor in the \(x\)- and/or \(z\)-direction. The \(K_0\) value of each model grid cell is then multiplied by the trend factors.

Full hydraulic-conductivity tensors for each model grid cell are  calculated by multiplying the isotropic hydraulic conductivity \(K^{iso}\), with a
a rotated anisotropy matrix \(\textbf{M}\):

\(\textbf{K}_i =K^{iso}_i\textbf{R}_i\textbf{M}_i\textbf{R}_i^T\)

\(\textbf{R}_i = \begin{bmatrix} \cos(\kappa_i)\cos(\psi_i) & \sin(\kappa_i) & \cos(\kappa_i)\sin(\psi_i)\\ -\sin(\kappa_i)\cos(\psi_i) & \cos(\kappa_i) & -\sin(\kappa_i)\sin(\psi_i)\\ -\sin(\psi_i) & 0 & \cos(\psi_i) \end{bmatrix}\)

Parameters \(\psi_i\) and \(\kappa_i\) are the simulated bedding structures (dip and azimuth, respectively). The anisotropy matrix \(\textbf{M}_i\) is diagonal with lateral terms set as equivalent (i.e. \(K_{xx} = K_{yy}\)). This approach is identical to that of \phantomsection\label{methods:id10}{\hyperref[references:bennett2017]{\sphinxcrossref{{[}BHC17{]}}}}. Once this has been completed, the simulated parameter files are saved and can be used for groundwater flow and solute transport simulations.


\chapter{HYVR inputs and outputs}
\label{inout::doc}\label{inout:hyvr-inputs-and-outputs}

\section{Parameter inputs and model outputs}
\label{inout:parameter-inputs-and-model-outputs}
Model input parameters are contained in \sphinxcode{*.ini} files which can be easily customized using your favourite text editor. This format was chosen for its readability and the ability to be used with numerous programming languages.

HYVR simulations are structured in the following way:

Model -\textgreater{} Run -\textgreater{} Realisation

The default operation of HYVR is to save simulation outputs in the same directory as the \sphinxcode{.ini} parameter input file. However, it is possible to save the simulation outputs into another directory by specifying {\color{red}\bfseries{}{}`{}`}run.modeldir'' in the parameter file.


\section{Model outputs}
\label{inout:model-outputs}

\subsection{MODFLOW input files}
\label{inout:modflow-input-files}

\chapter{HYVR Example}
\label{example::doc}\label{example:hyvr-example}
In this section we start to use HYVR. The model parameter input files are explained.


\section{The \texttt{.ini} configuration file}
\label{example:the-ini-configuration-file}
The key piece of information requried by HYVR is the parameter file. This is an \sphinxcode{.ini} configuration file that contains all the parameters required to run a HYVR simulation.

The parameter file is separated into sections denoted by headers surrounded by brackets (e.g. \sphinxcode{{[}section\_name{]}}). Parameters (or keys) and their associated values are then stipulated using the equals sign (e.g. \sphinxcode{key = value}). Each key is associated with the section in which it is located. Section and variable names should be in lower case. String values do nore require quotation marks in \sphinxcode{.ini} files.

In HYVR there following sections are necessary:
\begin{itemize}
\item {} 
\sphinxcode{{[}run{]}} - This contains parameters related to the model run.

\item {} 
\sphinxcode{{[}model{]}} - This contains details about the model dimensions

\item {} 
\sphinxcode{{[}sequences{]}} - In this section the sequence parameters are set.

\item {} 
\sphinxcode{{[}*architectural\_elements*{]}} - Each architectural element to be simulated in HYVR is included in its own section. Please see the subsection below for more information.

\item {} 
\sphinxcode{{[}hydraulics{]}} - This section includes information for setting the hydraulic properties of simulated features.

\end{itemize}

An additional section \sphinxcode{{[}flowtrans{]}} is included in some parameter files - this section included parameters used in groundwater flow and solute transport simulation packages not implemented in HYVR. \sphinxcode{.ini} files are readable by a range of programming languages so the user can also store and read flow and transport parameters from the configuration file.

A number of key prefixes are used in the configuration files to assist identification when the HYVR package reads the configuration file:
\begin{itemize}
\item {} 
\sphinxcode{r\_} - This prefix denotes the lower and upper bounds of a range of float values.

\item {} 
\sphinxcode{l\_} - This denotes a list of string values (no punctuation marks are required).

\item {} 
\sphinxcode{ll\_} - This prefix denote a list of lists, each enclosed in brackets.

\item {} 
\sphinxcode{flag\_} - keys with this prefix will be intepreted as true/false (boolean) values.

\end{itemize}


\section{Model setup sections}
\label{example:model-setup-sections}

\subsection{\texttt{{[}run{]}} section}
\label{example:run-section}\begin{itemize}
\item {} 
\sphinxcode{runname}                           - Name of the model simulation run

\item {} 
\sphinxcode{numsim}                            - Number of realisations to be generated

\item {} 
\sphinxcode{l\_dataoutputs}                     - Simulation output data formats {[}vtk, mat, py{]}

\item {} 
\sphinxcode{l\_modeloutputs}            - Simulation output model formats {[}mf, hgs{]}

\item {} 
\sphinxcode{fp}                                        - filepath/directory for simulation outputs

\item {} 
\sphinxcode{flag\_ow}                           - overwrite previous simulation with same name?

\item {} 
\sphinxcode{flag\_anisotropy}           - Generate anisotropy parameters?

\item {} 
\sphinxcode{flag\_het}                          - Generate heterogeneity?

\end{itemize}


\subsection{\texttt{{[}model{]}} section}
\label{example:model-section}\begin{itemize}
\item {} 
\sphinxcode{dx}, \sphinxcode{dy}, \sphinxcode{dz}        - Model grid cell dimensions

\item {} 
\sphinxcode{lx}, \sphinxcode{ly}, \sphinxcode{lz}        - Model domain dimensions

\item {} 
\sphinxcode{flag\_periodic}             - Periodic model domain? (Sheets/truncated ellipsoids only)

\item {} 
\sphinxcode{flag\_display}              - `Display'-type simulation? If this flag is set to \sphinxcode{true}, the simulated architectural elements are centred in the model domain so they can be viewed easily.

\item {} 
\sphinxcode{hetlev}                            - Hierarchical level at which heterogeneity should be simulated (ae, facies, internal)

\end{itemize}


\section{\texttt{{[}sequences{]}} section}
\label{example:sequences-section}\begin{itemize}
\item {} 
\sphinxcode{l\_seq}                                     - List of sequences

\item {} 
\sphinxcode{r\_seq\_top}                         - List of mean sequence contact elevations

\item {} 
\sphinxcode{ll\_seq\_contact\_model}      - Statistical parameters for sequence contact model

\item {} 
\sphinxcode{ae\_table}                          - Filepath for architectural element lookup table

\item {} 
\sphinxcode{seq\_contact}                       - Contact surface type (flat, random, user)

\item {} 
\sphinxcode{ll\_seq\_ae}                         - Which architectural elements are in each sequence

\item {} 
\sphinxcode{ll\_ae\_prob}                        - Probability of an architectural element occuring

\item {} 
\sphinxcode{ll\_ae\_z\_mean}                      - Mean thickness of architectural element unit

\item {} 
\sphinxcode{ll\_avul\_prob}                      - Probability of avulsion

\item {} 
\sphinxcode{ll\_avul}                           - Avulsion depth range

\item {} 
\sphinxcode{r\_bg}                                      - Background values for unassigned cells

\end{itemize}


\section{\texttt{{[}element{]}} sections for architectural elements}
\label{example:element-sections-for-architectural-elements}
Sections that describe architectural elements are entitled with an identifying name (e.g. \sphinxcode{{[}sparse\_scour{]}}). Note that section names should not include spaces. The first parameter to be set it the \sphinxcode{geometry}. The current implementation of HYVR includes three geometries: truncated ellipsoids (\sphinxcode{trunc\_ellip}), channels (\sphinxcode{channel}), and sheets (\sphinxcode{sheet}).


\subsection{General \texttt{{[}*element{]}} parameters}
\label{example:general-element-parameters}\begin{itemize}
\item {} 
\sphinxcode{geometry}                  - Geometry of architectural element (trunc\_ellip, channel, sheet)

\item {} 
\sphinxcode{structure}                 - Internal structure of architectural element

\end{itemize}


\subsection{Truncated ellipsoid parameters}
\label{example:truncated-ellipsoid-parameters}

\subsection{Channel parameters}
\label{example:channel-parameters}

\subsection{Sheet parameters}
\label{example:sheet-parameters}

\section{\texttt{{[}hydraulics{]}} section}
\label{example:hydraulics-section}
The input parameters in this section are associated with the simulation of hydraulic parameters. It is also possible to only simulate the geometries of architectural elements and hydrofacies if required.
\begin{itemize}
\item {} 
\sphinxcode{flag\_gen}                  - Generate hydraulic parameters (i.e. hydraulic conductivity)?

\item {} 
\sphinxcode{l\_hydro}                   - List of hydrofacies codes

\item {} 
\sphinxcode{r\_k\_h}                     - Mean horizontal hydraulic conductivity

\item {} 
\sphinxcode{r\_sig\_y}                   - Variance of log hydraulic conductivity

\item {} 
\sphinxcode{ll\_ycorlengths}    - Default correlation lengths for \(\log(K_{iso})\) in each hydrofacies in \(x,y,z\)-directions

\item {} 
\sphinxcode{r\_k\_ratio}                 - List of perpendicular anisotropy ratios (i.e \(\frac{K_h}{K_v}\))

\item {} 
\sphinxcode{r\_n}                               - List of mean porosity values

\item {} 
\sphinxcode{r\_sig\_n}                   - Variance of porosity values

\item {} 
\sphinxcode{ll\_ncorlengths}    - Default correlation lengths for porosity in each hydrofacies in \(x,y,z\)-directions

\end{itemize}


\section{\texttt{{[}flowtrans{]}} section}
\label{example:flowtrans-section}
This section contains parameters to be used for groundwater flow and solute transport simulations. This allows all input parameters for field generation and subsequent modelling to be stored in the same \sphinxcode{.ini} file.


\section{Example parameter file}
\label{example:example-parameter-file}
An example of a parameter file is included below.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Example HyVR model parameter input file}
\PYG{c+c1}{\PYGZsh{} HyVR 0.1 simulation package}
\PYG{c+c1}{\PYGZsh{} https://github.com/driftingtides/hyvr/}
\PYG{c+c1}{\PYGZsh{} Jeremy P. Bennett, University of Tübingen, 2017\PYGZhy{}2018 }

\PYG{c+c1}{\PYGZsh{} Notes:}
\PYG{c+c1}{\PYGZsh{}	\PYGZhy{} String values do not require quotation marks}
\PYG{c+c1}{\PYGZsh{} 	\PYGZhy{} All section and variable names should be lower case}

\PYG{c+c1}{\PYGZsh{} Suffixes}
\PYG{c+c1}{\PYGZsh{} r\PYGZus{}: 		range of float values}
\PYG{c+c1}{\PYGZsh{} l\PYGZus{}: 		list of string values}
\PYG{c+c1}{\PYGZsh{} ll\PYGZus{}:		list of tuples}
\PYG{c+c1}{\PYGZsh{} flag\PYGZus{}: 	flag value (boolean)}

\PYG{p}{[}\PYG{n}{run}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Run parameters}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{c+c1}{\PYGZsh{} Name of model simulation run}
\PYG{n}{runname} \PYG{o}{=} \PYG{n}{testing\PYGZus{}small1}

\PYG{c+c1}{\PYGZsh{} Number of realisations}
\PYG{n}{numsim} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Outputs}
\PYG{c+c1}{\PYGZsh{} Required outputs }
\PYG{c+c1}{\PYGZsh{} vtk: *.vtk}
\PYG{c+c1}{\PYGZsh{} py: python pickle}
\PYG{c+c1}{\PYGZsh{} mat *.mat}
\PYG{n}{l\PYGZus{}dataoutputs} \PYG{o}{=} \PYG{p}{[}\PYG{n}{vtk}\PYG{p}{,}\PYG{n}{mat}\PYG{p}{,}\PYG{n}{py}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}l\PYGZus{}modeloutputs = [mf,hgs]}

\PYG{c+c1}{\PYGZsh{} Full Filepath/directory for outputs}
\PYG{c+c1}{\PYGZsh{} Default is the directory of the parameter initialization file}
\PYG{c+c1}{\PYGZsh{} fp = made}

\PYG{c+c1}{\PYGZsh{} Overwrite parameter files}
\PYG{n}{flag\PYGZus{}ow} \PYG{o}{=} \PYG{n}{true}

\PYG{c+c1}{\PYGZsh{} Will anisotropy be assigned?}
\PYG{n}{flag\PYGZus{}anisotropy} \PYG{o}{=} \PYG{n}{true}
\PYG{n}{flag\PYGZus{}het} \PYG{o}{=} \PYG{n}{true}


\PYG{p}{[}\PYG{n}{model}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Model parameters}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{c+c1}{\PYGZsh{} Grid cell dimensions [m]}
\PYG{n}{dx} \PYG{o}{=} \PYG{l+m+mf}{0.5}
\PYG{n}{dy} \PYG{o}{=} \PYG{l+m+mf}{0.5}
\PYG{n}{dz} \PYG{o}{=} \PYG{l+m+mf}{0.1}

\PYG{c+c1}{\PYGZsh{} Model dimensions [m]}
\PYG{c+c1}{\PYGZsh{}lx = 200}
\PYG{n}{lx} \PYG{o}{=} \PYG{l+m+mi}{40}
\PYG{c+c1}{\PYGZsh{}ly = 70}
\PYG{n}{ly} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{n}{lz} \PYG{o}{=} \PYG{l+m+mi}{11}

\PYG{c+c1}{\PYGZsh{} Is domain periodic?}
\PYG{n}{flag\PYGZus{}periodic} \PYG{o}{=} \PYG{n}{false}
\PYG{n}{flag\PYGZus{}display} \PYG{o}{=}  \PYG{n}{false}

\PYG{c+c1}{\PYGZsh{} Lowest hierarchical level of heterogeneity to assign}
\PYG{c+c1}{\PYGZsh{}	\PYGZhy{}ae}
\PYG{c+c1}{\PYGZsh{}	\PYGZhy{}facies}
\PYG{c+c1}{\PYGZsh{} 	\PYGZhy{}internal}
\PYG{n}{hetlev} \PYG{o}{=} \PYG{n}{internal}

\PYG{p}{[}\PYG{n}{sequences}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Sequence parameters}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} List of sequences}
\PYG{n}{l\PYGZus{}seq} \PYG{o}{=} \PYG{p}{[}\PYG{n}{clay}\PYG{p}{,} \PYG{n}{transition}\PYG{p}{,} \PYG{n}{glaflu}\PYG{p}{,} \PYG{n}{meander}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} List of sequence top contact depths}
\PYG{n}{r\PYGZus{}seq\PYGZus{}top} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}  [variance, correlation length x, corr. length. y]}
\PYG{n}{ll\PYGZus{}seq\PYGZus{}contact\PYGZus{}model} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.05}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.05}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.05}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.05}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Architectural element lookup table}
\PYG{c+c1}{\PYGZsh{}ae\PYGZus{}table = ae\PYGZus{}lu\PYGZus{}19\PYGZhy{}09\PYGZhy{}2017\PYGZus{}10.39.18.txt}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Contact surfaces}
\PYG{c+c1}{\PYGZsh{} flat:		horizontal contacts \PYGZlt{}default\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{} random: random surfaces}
\PYG{c+c1}{\PYGZsh{} 				\PYGZhy{} requires geostatistical model \PYGZdq{}l\PYGZus{}contact\PYGZus{}model\PYGZdq{} }
\PYG{c+c1}{\PYGZsh{} user: 	Use\PYGZhy{}defined contact surfaces}
\PYG{c+c1}{\PYGZsh{} 				\PYGZhy{} requires input path \PYGZdq{}contact\PYGZus{}file\PYGZdq{}}
\PYG{n}{seq\PYGZus{}contact} \PYG{o}{=} \PYG{n}{random}

\PYG{c+c1}{\PYGZsh{} Which architectural elements are included in each sequence}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{} Must have same length as l\PYGZus{}seq, }
\PYG{c+c1}{\PYGZsh{} \PYGZhy{} Architectural elements must be identical to section names (except [model],[hydraulics])}
\PYG{n}{ll\PYGZus{}seq\PYGZus{}ae} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{clay\PYGZus{}sheet}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{sand\PYGZus{}sheet}\PYG{p}{,}\PYG{n}{clay\PYGZus{}lens}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{crossbedded\PYGZus{}scour}\PYG{p}{,} \PYG{n}{sandy\PYGZus{}gravel}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{mc\PYGZus{}sheet}\PYG{p}{,} \PYG{n}{meander\PYGZus{}channel}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} The probability of an architecutral element occuring }
\PYG{n}{ll\PYGZus{}ae\PYGZus{}prob} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+m+mf}{0.6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.8}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Mean thickness of architectural element}
\PYG{n}{ll\PYGZus{}ae\PYGZus{}z\PYGZus{}mean} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{3.0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.3}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{1.7}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Erosion / deposition rules}
\PYG{c+c1}{\PYGZsh{} Avulsion probability}
\PYG{n}{ll\PYGZus{}avul\PYGZus{}prob} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Avulsion depth range [m]}
\PYG{n}{ll\PYGZus{}avul} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Background parameters for unassigned cells}
\PYG{c+c1}{\PYGZsh{} [fac, azim, dip]}
\PYG{n}{r\PYGZus{}bg} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]} 


\PYG{p}{[}\PYG{n}{crossbedded\PYGZus{}scour}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Scour pool element}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{geometry} \PYG{o}{=} \PYG{n}{trunc\PYGZus{}ellip}

\PYG{c+c1}{\PYGZsh{} Internal structure }
\PYG{n}{structure} \PYG{o}{=} \PYG{n}{random}
\PYG{n}{agg} \PYG{o}{=} \PYG{l+m+mf}{0.2}

\PYG{c+c1}{\PYGZsh{} Contact type}
\PYG{n}{contact} \PYG{o}{=} \PYG{n}{random}
\PYG{c+c1}{\PYGZsh{}  [variance, correlation length x, corr. length. y]}
\PYG{n}{r\PYGZus{}contact\PYGZus{}model} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.01}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Number of elements per simulation elevation}
\PYG{n}{el\PYGZus{}z} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{n}{e}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}

\PYG{c+c1}{\PYGZsh{} Migration of troughs [mean \PYGZam{} var migration in x, y]}
\PYG{c+c1}{\PYGZsh{}r\PYGZus{}migrate = [10, 1, 10, 1]}

\PYG{c+c1}{\PYGZsh{} Do not generate troughs close to bottom contact}
\PYG{c+c1}{\PYGZsh{} Value is proportion of trough depth}
\PYG{n}{buffer} \PYG{o}{=} \PYG{l+m+mf}{0.8}

\PYG{c+c1}{\PYGZsh{} Mean trough geometry [m]}
\PYG{n}{length} \PYG{o}{=} \PYG{l+m+mi}{22}
\PYG{n}{width} \PYG{o}{=} \PYG{l+m+mf}{10.4}
\PYG{n}{depth} \PYG{o}{=} \PYG{l+m+mf}{1.2}

\PYG{c+c1}{\PYGZsh{} Mean angles [°]}
\PYG{n}{r\PYGZus{}paleoflow} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{]}
\PYG{n}{r\PYGZus{}dip} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{]}
\PYG{n}{r\PYGZus{}azimuth} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Hydrofacies (refer to [hydraulics]l\PYGZus{}hydro; 0\PYGZhy{}indexed)}
\PYG{n}{l\PYGZus{}facies} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Alternating facies}
\PYG{c+c1}{\PYGZsh{} List of what hydrofacies can follow those listed in l\PYGZus{}facies}
\PYG{c+c1}{\PYGZsh{} To generate cyclical facies each list entry should have only one facies value}
\PYG{n}{ll\PYGZus{}altfacies} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Thickness of lenses (or) spatial period (lambda) of inclined set [m]}
\PYG{n}{bulbset\PYGZus{}d} \PYG{o}{=} \PYG{l+m+mf}{0.1}
\PYG{n}{dipset\PYGZus{}d} \PYG{o}{=} \PYG{l+m+mf}{0.7}

\PYG{c+c1}{\PYGZsh{} Background parameters for unassigned cells}
\PYG{c+c1}{\PYGZsh{} [fac, azim, dip]}
\PYG{n}{r\PYGZus{}bg} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} 

\PYG{c+c1}{\PYGZsh{} Geometry trend with elevation}
\PYG{c+c1}{\PYGZsh{} Trends are linear, moving from bottom to top of domain}
\PYG{c+c1}{\PYGZsh{} Percentage change of mean value with dx = 1m}
\PYG{n}{r\PYGZus{}geo\PYGZus{}ztrend} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}

\PYG{p}{[}\PYG{n}{meander\PYGZus{}channel}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Meander channel element}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{geometry} \PYG{o}{=} \PYG{n}{channel}
\PYG{n}{width} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{depth} \PYG{o}{=} \PYG{l+m+mf}{1.5}

\PYG{c+c1}{\PYGZsh{} Internal structure }
\PYG{n}{structure} \PYG{o}{=} \PYG{n}{massive}
\PYG{n}{agg} \PYG{o}{=} \PYG{l+m+mi}{5}

\PYG{c+c1}{\PYGZsh{} Contact type}
\PYG{n}{contact} \PYG{o}{=} \PYG{n}{random}
\PYG{c+c1}{\PYGZsh{}  [variance, correlation length x, corr. length. y]}
\PYG{n}{r\PYGZus{}contact\PYGZus{}model} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.001}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}  Migration vector (x,y,z\PYGZhy{}difference between two channels per dz)}
\PYG{n}{r\PYGZus{}mig} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]} 

\PYG{c+c1}{\PYGZsh{} Channel shape parameters}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.4}
\PYG{c+c1}{\PYGZsh{} Wavenumber}
\PYG{n}{k} \PYG{o}{=} \PYG{l+m+mf}{0.3}	
\PYG{c+c1}{\PYGZsh{} Channel distance for calculations		}
\PYG{n}{ds} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{eps\PYGZus{}factor} \PYG{o}{=} \PYG{l+m+mf}{0.1}

\PYG{c+c1}{\PYGZsh{} Channels per iteration}
\PYG{n}{channel\PYGZus{}no} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{c+c1}{\PYGZsh{} Dip range ([0,0] = massive bedding without any dip)}
\PYG{n}{r\PYGZus{}dip} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Do not generate troughs close to bottom contact}
\PYG{c+c1}{\PYGZsh{} Value is proportion of trough depth}
\PYG{n}{buffer} \PYG{o}{=} \PYG{l+m+mf}{0.4}

\PYG{c+c1}{\PYGZsh{} Hydrofacies (refer to [hydraulics]l\PYGZus{}hydro; 0\PYGZhy{}indexed)}
\PYG{n}{l\PYGZus{}facies} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Lag surface at bottom of feature}
\PYG{c+c1}{\PYGZsh{} [lag depth, hydrofacies]}
\PYG{n}{l\PYGZus{}lag} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Background parameters for unassigned cells}
\PYG{c+c1}{\PYGZsh{} [mat, fac, azim, dip]}
\PYG{n}{r\PYGZus{}bg} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} 

\PYG{c+c1}{\PYGZsh{} Global hydraulics trend with elevation}
\PYG{c+c1}{\PYGZsh{} Trends are linear, moving from bottom to top of domain}
\PYG{n}{r\PYGZus{}k\PYGZus{}ztrend} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{0.9}\PYG{p}{]}

\PYG{p}{[}\PYG{n}{sandy\PYGZus{}gravel}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Sandy gravel sheet element}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Geometry}
\PYG{n}{geometry} \PYG{o}{=} \PYG{n}{sheet}
\PYG{n}{lens\PYGZus{}thickness} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{structure} \PYG{o}{=} \PYG{n}{massive}

\PYG{c+c1}{\PYGZsh{} Contact type}
\PYG{n}{contact} \PYG{o}{=} \PYG{n}{random}
\PYG{c+c1}{\PYGZsh{}  [variance, correlation length x, corr. length. y]}
\PYG{n}{r\PYGZus{}contact\PYGZus{}model} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.05}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Hydrofacies (refer to [hydraulics]l\PYGZus{}hydro)}
\PYG{n}{l\PYGZus{}facies} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{p}{[}\PYG{n}{sand\PYGZus{}sheet}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Sand sheet element}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Geometry}
\PYG{n}{geometry} \PYG{o}{=} \PYG{n}{sheet}
\PYG{n}{lens\PYGZus{}thickness} \PYG{o}{=} \PYG{l+m+mf}{0.3}
\PYG{n}{structure} \PYG{o}{=} \PYG{n}{massive}

\PYG{c+c1}{\PYGZsh{} Contact type}
\PYG{n}{contact} \PYG{o}{=} \PYG{n}{flat}

\PYG{c+c1}{\PYGZsh{}  [variance, correlation length x, corr. length. y]}
\PYG{n}{r\PYGZus{}contact\PYGZus{}model} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.01}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Dip range ([0,0] = massive bedding without any dip)}
\PYG{n}{r\PYGZus{}dip} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Spatial period (lambda) of inclined set [m]}
\PYG{n}{setlamb} \PYG{o}{=} \PYG{l+m+mf}{0.3}

\PYG{c+c1}{\PYGZsh{} Hydrofacies (refer to [hydraulics]l\PYGZus{}hydro)}
\PYG{n}{l\PYGZus{}facies} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Global hydraulics trend with elevation}
\PYG{c+c1}{\PYGZsh{} Trends are linear, moving from bottom to top of domain}
\PYG{n}{r\PYGZus{}k\PYGZus{}ztrend} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{p}{[}\PYG{n}{clay\PYGZus{}sheet}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Clay sheet element}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Geometry}
\PYG{n}{geometry} \PYG{o}{=} \PYG{n}{sheet}
\PYG{n}{lens\PYGZus{}thickness} \PYG{o}{=} \PYG{l+m+mf}{0.2}
\PYG{n}{structure} \PYG{o}{=} \PYG{n}{massive}

\PYG{c+c1}{\PYGZsh{} Contact type}
\PYG{n}{contact} \PYG{o}{=} \PYG{n}{flat}
\PYG{c+c1}{\PYGZsh{}  [variance, correlation length x, corr. length. y]}
\PYG{n}{r\PYGZus{}contact\PYGZus{}model} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.01}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Dip range ([0,0] = massive bedding without any dip)}
\PYG{n}{r\PYGZus{}dip} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Spatial period (lambda) of inclined set [m]}
\PYG{n}{setlamb} \PYG{o}{=} \PYG{l+m+mi}{3}

\PYG{c+c1}{\PYGZsh{} Hydrofacies (refer to [hydraulics]l\PYGZus{}hydro)}
\PYG{n}{l\PYGZus{}facies} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Global hydraulics trend with elevation}
\PYG{c+c1}{\PYGZsh{} Trends are linear, moving from bottom to top of domain}
\PYG{n}{r\PYGZus{}k\PYGZus{}ztrend} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}

\PYG{p}{[}\PYG{n}{mc\PYGZus{}sheet}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} silt/clay sheet element}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Geometry}
\PYG{n}{geometry} \PYG{o}{=} \PYG{n}{sheet}
\PYG{n}{lens\PYGZus{}thickness} \PYG{o}{=} \PYG{l+m+mf}{0.1}
\PYG{n}{structure} \PYG{o}{=} \PYG{n}{massive}

\PYG{c+c1}{\PYGZsh{} Contact type}
\PYG{n}{contact} \PYG{o}{=} \PYG{n}{flat}
\PYG{n}{r\PYGZus{}contact\PYGZus{}model} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.01}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Spatial period (lambda) of inclined set [m]}
\PYG{n}{setlamb} \PYG{o}{=} \PYG{l+m+mi}{3}

\PYG{c+c1}{\PYGZsh{} Dip range ([0,0] = massive bedding without any dip)}
\PYG{n}{r\PYGZus{}dip} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Hydrofacies (refer to [hydraulics]l\PYGZus{}hydro)}
\PYG{n}{l\PYGZus{}facies} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Global hydraulics trend with elevation}
\PYG{c+c1}{\PYGZsh{} Trends are linear, moving from bottom to top of domain}
\PYG{n}{r\PYGZus{}k\PYGZus{}ztrend} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}

\PYG{p}{[}\PYG{n}{clay\PYGZus{}lens}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Clay/silt lens}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{geometry} \PYG{o}{=} \PYG{n}{trunc\PYGZus{}ellip}

\PYG{c+c1}{\PYGZsh{} Internal structure }
\PYG{n}{structure} \PYG{o}{=} \PYG{n}{flat}
\PYG{n}{agg} \PYG{o}{=} \PYG{l+m+mf}{0.2}

\PYG{c+c1}{\PYGZsh{} Contact type}
\PYG{n}{contact} \PYG{o}{=} \PYG{n}{flat}
\PYG{c+c1}{\PYGZsh{}  [variance, correlation length x, corr. length. y]}
\PYG{n}{r\PYGZus{}contact\PYGZus{}model} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.01}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Number of elements per simulation elevation}
\PYG{n}{el\PYGZus{}z} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{n}{e}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}

\PYG{c+c1}{\PYGZsh{} Migration of troughs [mean \PYGZam{} var migration in x, y]}
\PYG{c+c1}{\PYGZsh{}r\PYGZus{}migrate = [20, 1, 10, 1]}

\PYG{c+c1}{\PYGZsh{} Do not generate troughs close to bottom contact}
\PYG{c+c1}{\PYGZsh{} Value is proportion of trough depth}
\PYG{c+c1}{\PYGZsh{} buffer = 0.2}

\PYG{c+c1}{\PYGZsh{} Mean trough geometry [m]}
\PYG{n}{length} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{width} \PYG{o}{=} \PYG{l+m+mi}{8}
\PYG{n}{depth} \PYG{o}{=} \PYG{l+m+mf}{0.3}

\PYG{c+c1}{\PYGZsh{} Mean angles [°]}
\PYG{n}{r\PYGZus{}paleoflow} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{90}\PYG{p}{,} \PYG{l+m+mi}{90}\PYG{p}{]}
\PYG{n}{r\PYGZus{}dip} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{r\PYGZus{}azimuth} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Hydrofacies (refer to [hydraulics]l\PYGZus{}hydro; 0\PYGZhy{}indexed)}
\PYG{n}{l\PYGZus{}facies} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Alternating facies}
\PYG{c+c1}{\PYGZsh{} List of what hydrofacies can follow those listed in l\PYGZus{}facies}
\PYG{c+c1}{\PYGZsh{} To generate cyclical facies each list entry should have only one facies value}
\PYG{n}{ll\PYGZus{}altfacies} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Thickness of lenses (or) spatial period (lambda) of inclined set [m]}
\PYG{n}{setlamb} \PYG{o}{=} \PYG{l+m+mf}{0.2}

\PYG{c+c1}{\PYGZsh{} Background parameters for unassigned cells}
\PYG{c+c1}{\PYGZsh{} [mat, fac, azim, dip]}
\PYG{n}{r\PYGZus{}bg} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} 

\PYG{c+c1}{\PYGZsh{} Geometry trend with elevation}
\PYG{c+c1}{\PYGZsh{} Trends are linear, moving from bottom to top of domain}
\PYG{c+c1}{\PYGZsh{} Percentage change of mean value with dx = 1m}
\PYG{n}{r\PYGZus{}geo\PYGZus{}ztrend} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{p}{[}\PYG{n}{hydraulics}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Hydraulic parameters}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Simulation of hydraulic parameters?}
\PYG{n}{flag\PYGZus{}gen} \PYG{o}{=} \PYG{n}{true}

\PYG{c+c1}{\PYGZsh{} List of hydrofacies codes}
\PYG{n}{l\PYGZus{}hydro} \PYG{o}{=} \PYG{p}{[}\PYG{n}{sG}\PYG{p}{,} \PYG{n}{scG}\PYG{p}{,} \PYG{n}{oG}\PYG{p}{,} \PYG{n}{S}\PYG{p}{,} \PYG{n}{fS}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{mS}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} mean horizontal hydraulic conductivity [m/s]}
\PYG{n}{r\PYGZus{}k\PYGZus{}h} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{n}{e}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{n}{e}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{n}{e}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{n}{e}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{n}{e}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{n}{e}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{n}{e}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{9}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} variance of log hydraulic conductivity [\PYGZhy{}]}
\PYG{n}{r\PYGZus{}sig\PYGZus{}y} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} default correlation lengths for log(K) in each hydrofacies in x,y,z\PYGZhy{}directions}
\PYG{n}{ll\PYGZus{}ycorlengths} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mf}{1.6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mf}{1.6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mf}{1.6}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mf}{1.6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mf}{1.6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mf}{1.6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mf}{1.6}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} List of perpendicular anisotropy ratios (i.e K\PYGZus{}h/K\PYGZus{}v) [\PYGZhy{}]}
\PYG{n}{r\PYGZus{}k\PYGZus{}ratio} \PYG{o}{=}  \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{l+m+mf}{0.025}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{2.3}\PYG{p}{,} \PYG{l+m+mf}{2.3}\PYG{p}{,} \PYG{l+m+mf}{2.3}\PYG{p}{,} \PYG{l+m+mf}{1.7}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} list of mean porosity values [\PYGZhy{}]}
\PYG{n}{r\PYGZus{}n} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.17}\PYG{p}{,} \PYG{l+m+mf}{0.35}\PYG{p}{,} \PYG{l+m+mf}{0.43}\PYG{p}{,} \PYG{l+m+mf}{0.43}\PYG{p}{,} \PYG{l+m+mf}{0.52}\PYG{p}{,} \PYG{l+m+mf}{0.45}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} variance of porosity values [\PYGZhy{}]}
\PYG{n}{r\PYGZus{}sig\PYGZus{}n} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.0005}\PYG{p}{,} \PYG{l+m+mf}{0.0005}\PYG{p}{,} \PYG{l+m+mf}{0.0005}\PYG{p}{,} \PYG{l+m+mf}{0.0005}\PYG{p}{,} \PYG{l+m+mf}{0.0005}\PYG{p}{,} \PYG{l+m+mf}{0.0005}\PYG{p}{,}\PYG{l+m+mf}{0.0005}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} default correlation lengths for n in each hydrofacies in x,y,z\PYGZhy{}directions}
\PYG{n}{ll\PYGZus{}ncorlengths} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Global hydraulics trend with elevation}
\PYG{c+c1}{\PYGZsh{} Trends are linear, moving from bottom to top of domain}
\PYG{c+c1}{\PYGZsh{}r\PYGZus{}k\PYGZus{}ztrend = [1.5, 0.9]}
\PYG{c+c1}{\PYGZsh{}r\PYGZus{}k\PYGZus{}xtrend = [1.5, 0.9]}


\PYG{p}{[}\PYG{n}{flowtrans}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Flow and transport modelling parameters}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{c+c1}{\PYGZsh{} Boundary conditions (head in/out [m])}
\PYG{n}{hin} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{hout} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}


\end{Verbatim}


\chapter{Extending HYVR}
\label{more::doc}\label{more:extending-hyvr}
The HYVR package is a work in progress. It has been implemented in Python in order to make it accessible for researchers, easily customisable, and hopefully somewhat easy to extend to suit the needs of future research. In this section I have included some tips on ways to extend the HYVR source code.


\section{Adding more geometries}
\label{more:adding-more-geometries}
HYVR has been set up in such a way to facilitate the implementation of additional architectural element geometries.

In order to generate new types of geometries a new function needs to be written in the \sphinxcode{hyvr} module that will be called from \sphinxcode{hyvr.hyvr\_main()} where individual architectural elements and hydrofacies are simulated (around line 188 of \sphinxcode{hyvr.hyvr\_main()}).

Any new geometry function needs to return the following properties:
\begin{itemize}
\item {} 
\sphinxcode{mat} (numpy array)

\item {} 
\sphinxcode{azim} (numpy array)

\item {} 
\sphinxcode{dip} (numpy array)

\item {} 
\sphinxcode{fac} (numpy array)

\item {} 
\sphinxcode{ae\_arr\_i} (numpy array)

\end{itemize}


\section{The HYVR wish list}
\label{more:the-hyvr-wish-list}
Any modelling project will have `areas for growth' (as opposed to weaknesses). I have identified some things that I would like HYVR to have, but that are outside of the scope of my PhD research (and funds...). Perhaps you have the time and need to complete these yourself?
\begin{itemize}
\item {} 
Extensions in \sphinxcode{C} programming language to speed up bottlenecks in simulations, particularly in \sphinxcode{hyvr.scale\_rotate'{'}, {}`{}`hyvr.reindex}, and \sphinxcode{hyvr.planepoint}.

\item {} 
Some level of conditioning, or improved interfacing with multiple-point geostatistical packages.

\item {} 
Interaction of channels, as well as more complex/realisitic configurations of channel deposits (e.g. point bars).

\item {} 
Utilities for deriving HYVR simulation parameters from transitional probability geostatistics.

\item {} 
Simulation of chemofacies.

\end{itemize}


\chapter{References}
\label{references:references}\label{references::doc}



\chapter{hyvr}
\label{modules::doc}\label{modules:hyvr}

\section{hyvr package}
\label{hyvr::doc}\label{hyvr:hyvr-package}

\subsection{Submodules}
\label{hyvr:submodules}

\subsection{hyvr.hyvr.grid module}
\label{hyvr:hyvr-hyvr-grid-module}\label{hyvr:module-hyvr.hyvr.grid}\index{hyvr.hyvr.grid (module)}
Grid class
\begin{quote}

A module containing some classes and function useful to work with structured grids.
\end{quote}
\begin{quote}\begin{description}
\item[{Usage}] \leavevmode
Import as a normal python module.

\item[{Version}] \leavevmode
0.1 , 01-09-2016 : Forked from Alessandro Comunian

\item[{Authors}] \leavevmode
Jeremy P. Bennett
\begin{description}
\item[{Notes:}] \leavevmode
The grids for the moment are always considered as 3D.

\end{description}

\end{description}\end{quote}
\index{Grid (class in hyvr.hyvr.grid)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{hyvr.hyvr.grid.}\sphinxbfcode{Grid}}{\emph{ox=0.0}, \emph{oy=0.0}, \emph{oz=0.0}, \emph{dx=1.0}, \emph{dy=1.0}, \emph{dz=1.0}, \emph{nx=200}, \emph{ny=200}, \emph{nz=10}, \emph{gtype='points'}, \emph{gname='image'}, \emph{periodicity=False}}{}
Bases: \sphinxcode{object}

Grid class

A simple class that contains the \emph{Origin}, \emph{Delta} and \emph{Size} of a
simulation. It can also be used as container for some information
contained in a VTK structured grid file.
\paragraph{Notes}
\begin{itemize}
\item {} 
By default, the size of the grid is considered as points.

\end{itemize}


\sphinxstrong{See also:}


\sphinxcode{vtknumpy}


\index{cart\_coords() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.cart_coords}\pysiglinewithargsret{\sphinxbfcode{cart\_coords}}{}{}
Get x,y,z coordinates in a tuple

Parameters:
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A Tuple containing the x,y and z-coordinates of the grid

\end{description}\end{quote}

\end{fulllineitems}

\index{cart\_coords2d() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.cart_coords2d}\pysiglinewithargsret{\sphinxbfcode{cart\_coords2d}}{}{}
Get x,y coordinates in a tuple
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
A tuple containing the x,y-coordinates of the grid

\end{description}\end{quote}

\end{fulllineitems}

\index{cells (hyvr.hyvr.grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.cells}\pysigline{\sphinxbfcode{cells}}
Number of cells

\end{fulllineitems}

\index{cellsize\_2d() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.cellsize_2d}\pysiglinewithargsret{\sphinxbfcode{cellsize\_2d}}{}{}
Compute the cell size in 2D
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Cell size in 2D

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_max() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.compute_max}\pysiglinewithargsret{\sphinxbfcode{compute\_max}}{}{}
Compute the max values for \emph{x}, \emph{y} and \emph{z} of the grid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Max values of x,y and z

\end{description}\end{quote}

\end{fulllineitems}

\index{cs2 (hyvr.hyvr.grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.cs2}\pysigline{\sphinxbfcode{cs2}}
Some helpful things for getting grid indices

\end{fulllineitems}

\index{del\_cells() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.del_cells}\pysiglinewithargsret{\sphinxbfcode{del\_cells}}{}{}
Delete the cells for a cells grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\end{description}\end{quote}

Returns:

\end{fulllineitems}

\index{del\_lx() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.del_lx}\pysiglinewithargsret{\sphinxbfcode{del\_lx}}{}{}
Delete the x-dimension of a grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Tuple containing the size of a grid in x-direction

\end{description}\end{quote}

\end{fulllineitems}

\index{del\_ly() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.del_ly}\pysiglinewithargsret{\sphinxbfcode{del\_ly}}{}{}
Delete the y-dimension of a grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Tuple containing the size of a grid in y-direction

\end{description}\end{quote}

\end{fulllineitems}

\index{del\_lz() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.del_lz}\pysiglinewithargsret{\sphinxbfcode{del\_lz}}{}{}
Delete the z-dimension of a grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Tuple containing the size of a grid in z-direction

\end{description}\end{quote}

\end{fulllineitems}

\index{del\_points() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.del_points}\pysiglinewithargsret{\sphinxbfcode{del\_points}}{}{}
Delete the points of a points grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\end{description}\end{quote}

Returns:

\end{fulllineitems}

\index{get\_cells() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.get_cells}\pysiglinewithargsret{\sphinxbfcode{get\_cells}}{}{}
Update the number of cells for a cells grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Number of cells for x, y and z

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_lx() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.get_lx}\pysiglinewithargsret{\sphinxbfcode{get\_lx}}{}{}
Provide as output a tuple containing the x-size of a
grid. Useful for the implementation of `property'.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Tuple containing the size of a grid in x-direction

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ly() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.get_ly}\pysiglinewithargsret{\sphinxbfcode{get\_ly}}{}{}
Provide as output a tuple containing the y-size of a
grid. Useful for the implementation of `property'.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Tuple containing the size of a grid in y-direction

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_lz() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.get_lz}\pysiglinewithargsret{\sphinxbfcode{get\_lz}}{}{}
Provide as output a tuple containing the z-size of a
grid. Useful for the implementation of `property'.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Tuple containing the size of a grid in z-direction

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_points() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.get_points}\pysiglinewithargsret{\sphinxbfcode{get\_points}}{}{}
Update the number of points for a points grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Number of points for a points grid

\end{description}\end{quote}

\end{fulllineitems}

\index{idx\_z() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.idx_z}\pysiglinewithargsret{\sphinxbfcode{idx\_z}}{\emph{zval}}{}
Return the index of an elevation for the k-dimension of a 3D array
\begin{description}
\item[{Parameter:}] \leavevmode
zval:               Elevation value

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\textbf{iz} -- Index of elevation

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{lx (hyvr.hyvr.grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.lx}\pysigline{\sphinxbfcode{lx}}
`size' along \emph{x} of the grid.

\end{fulllineitems}

\index{ly (hyvr.hyvr.grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.ly}\pysigline{\sphinxbfcode{ly}}
`size' along \emph{y} of the grid.

\end{fulllineitems}

\index{lz (hyvr.hyvr.grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.lz}\pysigline{\sphinxbfcode{lz}}
`size' along \emph{z} of the grid.

\end{fulllineitems}

\index{meshup() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.meshup}\pysiglinewithargsret{\sphinxbfcode{meshup}}{\emph{ind='ij'}}{}
Create a meshgrid representation of the grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
A tuple containing the x,y,z-coordinates of the grid

\end{description}\end{quote}

\end{fulllineitems}

\index{meshup2d() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.meshup2d}\pysiglinewithargsret{\sphinxbfcode{meshup2d}}{\emph{ind='ij'}}{}
Create a 2D meshgrid representation of the grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
A tuple containing the x,y-coordinates of the grid

\end{description}\end{quote}

\end{fulllineitems}

\index{origin() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.origin}\pysiglinewithargsret{\sphinxbfcode{origin}}{}{}
To print out the origin of the grid as a tuple
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
A tuple containing the origin defined in the grid

\end{description}\end{quote}

\end{fulllineitems}

\index{points (hyvr.hyvr.grid.Grid attribute)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.points}\pysigline{\sphinxbfcode{points}}
Number of points

\end{fulllineitems}

\index{print\_intervals() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.print_intervals}\pysiglinewithargsret{\sphinxbfcode{print\_intervals}}{\emph{axis='xyz'}}{}
Print the intervals that constitute the simulation domain in a format like:
\begin{quote}

{[} ox, ox+nx*dx{]} {[} oy, oy+ny*dy{]} {[} oz, oz+nz*dz{]}
\end{quote}

where \emph{ox} is the origin, \emph{nx} is the number of points and \emph{dx}
is the delta between points (\emph{idem} for \emph{y} and \emph{z}).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{axis}} (\emph{\texttt{string}}) -- containing {[}'x','y','z'{]}, {[}optional{]}
If the default value ``xyz'' is used, then all the intevals are printed.

\item[{Returns}] \leavevmode
print intervals that constitute the simulation domain

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_cells() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.set_cells}\pysiglinewithargsret{\sphinxbfcode{set\_cells}}{\emph{val=None}}{}
Set the number of cells for a cells grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Number of cells for x, y and z

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_lx() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.set_lx}\pysiglinewithargsret{\sphinxbfcode{set\_lx}}{\emph{val=None}}{}
Set the x-size of a grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Tuple containing the size of a grid in x-direction

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_ly() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.set_ly}\pysiglinewithargsret{\sphinxbfcode{set\_ly}}{}{}
Set the y-size of a grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Tuple containing the size of a grid in y-direction

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_lz() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.set_lz}\pysiglinewithargsret{\sphinxbfcode{set\_lz}}{}{}
Set the z-size of a grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Tuple containing the size of a grid in z-direction

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_points() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.set_points}\pysiglinewithargsret{\sphinxbfcode{set\_points}}{\emph{val=None}}{}
Set the number of points for a points grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Number of points for a points grid

\end{description}\end{quote}

\end{fulllineitems}

\index{shape() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.shape}\pysiglinewithargsret{\sphinxbfcode{shape}}{}{}
To print out the shape of the grid as a tuple
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self}} -- An instance of the Grid class

\item {} 
\textbf{\texttt{gtype}} (\emph{\texttt{string}}) -- `points' or `cells'. String to decide to print the shape in terms of points or in terms of cells.

\end{itemize}

\item[{Returns}] \leavevmode
A tuple containing the shape defined in the grid

\end{description}\end{quote}

\end{fulllineitems}

\index{spacing() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.spacing}\pysiglinewithargsret{\sphinxbfcode{spacing}}{}{}
To print out the spacing of the grid as a tuple
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
A tuple containing the spacing defined in the grid

\end{description}\end{quote}

\end{fulllineitems}

\index{vec() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.vec}\pysiglinewithargsret{\sphinxbfcode{vec}}{}{}
Create vectors of spatial coordinates
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Vectors of spatial coordinates

\item[{Return type}] \leavevmode
xv, yv, zv

\end{description}\end{quote}

\end{fulllineitems}

\index{vec\_node() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.vec_node}\pysiglinewithargsret{\sphinxbfcode{vec\_node}}{}{}
Create vectors of spatial coordinates of bounding nodes
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Vectors of spatial coordinates of bounding nodes

\item[{Return type}] \leavevmode
xv, yv, zv

\end{description}\end{quote}

\end{fulllineitems}

\index{vec\_x() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.vec_x}\pysiglinewithargsret{\sphinxbfcode{vec\_x}}{}{}
Create vector of spatial x-coordinate
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Vector of spatial x-coordinate

\item[{Return type}] \leavevmode
xv

\end{description}\end{quote}

\end{fulllineitems}

\index{vec\_y() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.vec_y}\pysiglinewithargsret{\sphinxbfcode{vec\_y}}{}{}
Create vector of spatial y-coordinate
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Vector of spatial y-coordinate

\item[{Return type}] \leavevmode
yv

\end{description}\end{quote}

\end{fulllineitems}

\index{vec\_z() (hyvr.hyvr.grid.Grid method)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.grid.Grid.vec_z}\pysiglinewithargsret{\sphinxbfcode{vec\_z}}{}{}
Create vector of spatial z-coordinate
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- An instance of the Grid class

\item[{Returns}] \leavevmode
Vector of spatial z-coordinate

\item[{Return type}] \leavevmode
zv

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{hyvr.hyvr.sim module}
\label{hyvr:hyvr-hyvr-sim-module}\label{hyvr:module-hyvr.hyvr.sim}\index{hyvr.hyvr.sim (module)}
Hydrogeological Virtual Reality simulation package.

Hydrogeological virtual reality (HYVR) simulator for object-based modelling of sedimentary structures
\paragraph{Notes}

Grid nodes are cell-centred!
\index{angle() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.angle}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{angle}}{\emph{v1}, \emph{v2}}{}
Return angle between two vectors in {[}°{]}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{v1}} -- Vector 1

\item {} 
\textbf{\texttt{v2}} -- Vector 2

\end{itemize}

\item[{Returns}] \leavevmode
Angle between v1 and v2

\end{description}\end{quote}

\end{fulllineitems}

\index{channel\_checker() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.channel_checker}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{channel\_checker}}{\emph{param\_file}, \emph{ae\_name}, \emph{no\_channels=1}, \emph{dist=0}}{}
channel\_checker function for quickly assessing the shape of channel inputs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{param\_file}} (\emph{\texttt{str}}) -- Parameter file location

\item {} 
\textbf{\texttt{ae\_name}} (\emph{\texttt{str}}) -- Name of architectural element

\item {} 
\textbf{\texttt{no\_channels}} (\emph{\texttt{float}}) -- Number of channels

\item {} 
\textbf{\texttt{dist}} (\emph{\texttt{float}}) -- Distance to generate channels - defaults to mg.lx

\end{itemize}

\item[{Returns}] \leavevmode
Plots showing shape of Ferguson channels

\end{description}\end{quote}

\end{fulllineitems}

\index{curve\_interp() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.curve_interp}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{curve\_interp}}{\emph{xc}, \emph{yc}, \emph{spacing}}{}
Interpolate evenly spaced points along a curve. This code is based on code in an answer posted by `Unutbu' on
\url{http://stackoverflow.com/questions/19117660/how-to-generate-equispaced-interpolating-values} (retrieved 17/04/2017)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{xc}} -- x coordinates of curve

\item {} 
\textbf{\texttt{yc}} -- y coordinates of curve

\item {} 
\textbf{\texttt{spacing}} -- Spacing between points

\end{itemize}

\item[{Returns}] \leavevmode
x coordinates of interpolated points
yn:                     y coordinates of interpolated points

\item[{Return type}] \leavevmode
xn

\end{description}\end{quote}

\end{fulllineitems}

\index{dip\_rotate() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.dip_rotate}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{dip\_rotate}}{\emph{azimuth\_in}, \emph{dip\_in}}{}
Rotate dip angle based on azimuth
Note that inputs and outputs are in degrees
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{azimuth\_in}} -- Azimuth input angle

\item {} 
\textbf{\texttt{dip\_in}} -- Dipping input angle

\end{itemize}

\item[{Returns}] \leavevmode
Azimuth output angle

\item[{Return type}] \leavevmode
dip\_out

\end{description}\end{quote}

\end{fulllineitems}

\index{dip\_sets() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.dip_sets}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{dip\_sets}}{\emph{mg}, \emph{aep}, \emph{znow}, \emph{channel={[}{]}}, \emph{select={[}{]}}, \emph{azimuth\_z=0}}{}
Generate dip angles and assign to the dip matrix
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{mg}} -- Mesh grid object class

\item {} 
\textbf{\texttt{aep}} -- Architectural element parameters (dict)

\item {} 
\textbf{\texttt{channel}} -- Tuple of x,y coordinates of channel (omitted for linear flows)
- x, y coordinates of channel
- vx, vy of channel flow

\item {} 
\textbf{\texttt{select}} -- Model grid nodes to assign

\end{itemize}

\item[{Returns}] \leavevmode
Array of assigned dip values
fac\_out:    Array of assigned hydrofacies

\item[{Return type}] \leavevmode
dip\_out

\end{description}\end{quote}

\end{fulllineitems}

\index{ellipsoid\_gradient() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.ellipsoid_gradient}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{ellipsoid\_gradient}}{\emph{x}, \emph{y}, \emph{z}, \emph{a}, \emph{b}, \emph{c}, \emph{alpha}, \emph{select}, \emph{tr}}{}
Calculate dip and strike values in rotated ellipsoids
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{y, z}} (\emph{\texttt{x,}}) -- Distances to centre of ellipsoid

\item {} 
\textbf{\texttt{b, c}} (\emph{\texttt{a,}}) -- Majox/minor axes of ellipsoid

\item {} 
\textbf{\texttt{alpha}} -- Rotation of ellipsoid from mean flow direction

\end{itemize}

\item[{Returns}] \leavevmode
Dipping in 3D
azimuth\_g:              Azimuth in 3D

\item[{Return type}] \leavevmode
dip\_g

\end{description}\end{quote}

\end{fulllineitems}

\index{facies() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.facies}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{facies}}{\emph{run}, \emph{model}, \emph{sequences}, \emph{hydraulics}, \emph{flowtrans}, \emph{elements}, \emph{mg}}{}
Generate hydrofacies fields
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{run}} -- Model run parameters like \sphinxcode{runname}, \sphinxcode{rundir}, \sphinxcode{l\_dataoutputs}, \sphinxcode{l\_modeloutputs}, etc.

\item {} 
\textbf{\texttt{model}} -- Model domain parameters

\item {} 
\textbf{\texttt{sequences}} -- Details about the sequences

\item {} 
\textbf{\texttt{hydraulics}} -- Details about the hydraulics

\item {} 
\textbf{\texttt{flowtrans}} -- Flow \& transport simulation parameters

\item {} 
\textbf{\texttt{elements}} -- Architectural elements and parametersX

\item {} 
\textbf{\texttt{mg}} -- Mesh grid object class

\end{itemize}

\item[{Returns}] \leavevmode

\textbf{probs} --
\begin{description}
\item[{Contains data of architectural element units and associated hydrofacies}] \leavevmode
if model parameter `flag\_anisotropy':
\begin{quote}

azim =                              Azimuth angles
mat =                               Material values
dip =                               Dipping angles
fac =                               Facies values
ae\_arr =                    Array with architectural element unit details
seq\_arr =                   Array with sequence details
\end{quote}

else
\begin{quote}

mat =                               Material values
fac =                               Facies values
\end{quote}

\end{description}

params (list):                  Contains parameters of model domain, sequence, hydraulics, etc.
\begin{quote}

run (dict) =                    Model run parameters
model (dict) =                  Model domain parameters
sequences (dict) =              Sequence parameters
hydraulics (dict) =             Hydraulic properties parameters
flowtrans (dict) =              Flow \& transport simulation parameters
elements (dict) =               Architectural elements and parameters
mg =                                    Mesh grid object class
ae\_lu =                                 Architectural element lookup table
\end{quote}


\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{ferguson\_channel() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.ferguson_channel}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{ferguson\_channel}}{\emph{mg}, \emph{h}, \emph{k}, \emph{ds}, \emph{eps\_factor}, \emph{dist=0}, \emph{disp=False}}{}
Simulate channel centrelines using the Ferguson (1976) disturbed meander model
Implementation of AR2 autoregressive model
\url{http://onlinelibrary.wiley.com/doi/10.1002/esp.3290010403/full}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{mg}} (\emph{\texttt{object class}}) -- Mesh grid object class

\item {} 
\textbf{\texttt{h}} (\emph{\texttt{float}}) -- Height

\item {} 
\textbf{\texttt{k}} (\emph{\texttt{float}}) -- Wave number

\item {} 
\textbf{\texttt{ds}} (\emph{\texttt{float}}) -- Channel distance for calculations

\item {} 
\textbf{\texttt{eps\_factor}} (\emph{\texttt{float}}) -- Random background noise

\item {} 
\textbf{\texttt{dist}} (\emph{\texttt{float}}) -- Distance to generate channels - defaults to mg.lx

\item {} 
\textbf{\texttt{disp}} (\emph{\texttt{bool}}) -- Creating display channel - channel begins at (0,0)

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{outputs} -- Simulated channel centerlines: storage array containing values for x coordinate, y coordinate, vx and vy

\item[{Return type}] \leavevmode
float array

\end{description}\end{quote}

\end{fulllineitems}

\index{ferguson\_theta() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.ferguson_theta}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{ferguson\_theta}}{\emph{s}, \emph{eps\_factor}, \emph{k}, \emph{h}}{}
Calculate channel direction angle
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{s}} -- Steps within generated channel distance

\item {} 
\textbf{\texttt{eps\_factor}} -- Random background noise

\item {} 
\textbf{\texttt{k}} -- Wave number

\item {} 
\textbf{\texttt{h}} -- Height

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{th\_store} -- Channel direction angle

\item[{Return type}] \leavevmode
array

\end{description}\end{quote}

\end{fulllineitems}

\index{gen\_channel() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.gen_channel}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{gen\_channel}}{\emph{ch\_par}, \emph{mg}, \emph{model}, \emph{seq}, \emph{ae\_array}, \emph{count}, \emph{ani=True}}{}~\begin{description}
\item[{Generate channels architectural element:}] \leavevmode\begin{itemize}
\item {} 
Flow regime is assumed to be reasonably constant so the major geometry of the channels doesn't change so much

\item {} 
`Migration' of the channels according to a shift vector

\end{itemize}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{ch\_par}} -- Channel parameters

\item {} 
\textbf{\texttt{mg}} -- Mesh grid object class

\item {} 
\textbf{\texttt{model}} (\emph{\texttt{dict}}) -- Model domain parameters

\item {} 
\textbf{\texttt{seq}} (\emph{\texttt{dict}}) -- Sequence parameters

\item {} 
\textbf{\texttt{ae\_array}} -- Array with architectural element unit details

\item {} 
\textbf{\texttt{count}} (\emph{\texttt{int}}) -- Material number and/or identifier

\item {} 
\textbf{\texttt{ani}} (\emph{\texttt{bool}}) -- Boolean if anisotropy is to be generated

\item {} 
\textbf{\texttt{(z\_in}} -- starting depth)

\item {} 
\textbf{\texttt{(thickness}} -- Thickness of architectural element)

\end{itemize}

\item[{Returns}] \leavevmode

Contains data of architectural element units and associated hydrofacies
\begin{quote}

if `ani':
\begin{quote}

mat =                       Material values
azim =                      Azimuth angles
dip =                       Dipping angles
fac =                       Facies values
ae\_arr\_i =          Array with architectural element unit details
\end{quote}

else
\begin{quote}

mat =                       Material values
fac =                       Facies values
ae\_arr\_i =          Array with architectural element unit details
\end{quote}
\end{quote}

count (int):    Material number and/or identifier


\item[{Return type}] \leavevmode
probs

\end{description}\end{quote}

\end{fulllineitems}

\index{gen\_sheet() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.gen_sheet}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{gen\_sheet}}{\emph{sh}, \emph{mg}, \emph{ae\_i}, \emph{ae\_array}, \emph{count}, \emph{ani=True}}{}
Generate gravel sheet with internal heterogeneity
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{sh}} -- Sheet parameters

\item {} 
\textbf{\texttt{mg}} -- Model grid class

\item {} 
\textbf{\texttt{ae\_i}} -- Architectural element lookup details {[}sequence number, z\_bottom, z\_top, architectural element, geometry{]}

\item {} 
\textbf{\texttt{ae\_array}} -- Architectural element array

\item {} 
\textbf{\texttt{count}} (\emph{\texttt{int}}) -- Material number and/or identifier

\item {} 
\textbf{\texttt{ani}} (\emph{\texttt{bool}}) -- Boolean if anisotropy is to be generated

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{probs} -- Contains data of architectural element units and associated hydrofacies (e.g. values of azimuth, material, dipping, etc.)
count (int):    Material number and/or identifier

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{gen\_trough() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.gen_trough}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{gen\_trough}}{\emph{tr}, \emph{mg}, \emph{model}, \emph{ae}, \emph{ae\_arr}, \emph{count}, \emph{ani=True}}{}
Create trough shapes
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{tr}} (\emph{\texttt{dict}}) -- Trough parameters

\item {} 
\textbf{\texttt{mg}} (\emph{\texttt{grid class}}) -- Model grid

\item {} 
\textbf{\texttt{ae}} (\emph{\texttt{list}}) -- Architectural element unit details

\item {} 
\textbf{\texttt{ae\_arr}} (\emph{\texttt{ndarray}}) -- 3D array of sequeunce numbers

\item {} 
\textbf{\texttt{count}} (\emph{\texttt{int}}) -- Material number and/or identifier

\item {} 
\textbf{\texttt{ani}} (\emph{\texttt{bool}}) -- Boolean if anisotropy is to be generated

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{probs} -- Grid properties
count (int):                    Material number and/or identifier

\item[{Return type}] \leavevmode
numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{heterogeneity() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.heterogeneity}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{heterogeneity}}{\emph{props}, \emph{params}}{}
Generate internal heterogeneity
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{probs}} (\emph{\texttt{list}}) -- Data of architectural element units and associated hydrofacies (e.g. values of azimuth, material, dipping, etc.)

\item {} 
\textbf{\texttt{params}} (\emph{\texttt{list}}) -- Parameters of model domain, sequence, hydraulics, etc.

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{probs} -- Data of architectural element units and associated hydrofacies
params (list):                  Input parameters, assigned with heterogenity

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.main}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{main}}{\emph{param\_file}}{}
Main function for HYVR generation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{param\_file}} (\emph{\texttt{str}}) -- Parameter file location

\item[{Returns}] \leavevmode
Save data outputs as parameter file

\end{description}\end{quote}

\end{fulllineitems}

\index{planepoint() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.planepoint}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{planepoint}}{\emph{dip\_norm}, \emph{x\_dip}, \emph{y\_dip}, \emph{znow}, \emph{xtemp}, \emph{ytemp}, \emph{ztemp}, \emph{select={[}{]}}}{}
Compute number of planes
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{dip\_norm}} -- 

\item {} 
\textbf{\texttt{x\_dip}} -- X coordinates of points on dip planes

\item {} 
\textbf{\texttt{y\_dip}} -- Y coordinates of points on dip planes

\item {} 
\textbf{\texttt{znow}} -- Current coordinates of Z, needed to compute Z coordinates of points on dip planes

\item {} 
\textbf{\texttt{xtemp}} -- X dimension of model grid nodes

\item {} 
\textbf{\texttt{ytemp}} -- Y dimension of model grid nodes

\item {} 
\textbf{\texttt{ztemp}} -- Z dimension of model grid nodes

\item {} 
\textbf{\texttt{select}} -- Model grid nodes to consider

\end{itemize}

\item[{Returns}] \leavevmode
Number of planes with selected model grid nodes

\item[{Return type}] \leavevmode
set\_no

\end{description}\end{quote}

\end{fulllineitems}

\index{prob\_choose() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.prob_choose}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{prob\_choose}}{\emph{choices}, \emph{probs}}{}
Get random values of an architectural element
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{choices}} -- Fixed number of choices

\item {} 
\textbf{\texttt{probs}} -- Contains data of architectural element units and associated hydrofacies

\end{itemize}

\item[{Returns}] \leavevmode
Random value of architectural elements

\item[{Return type}] \leavevmode
choice

\end{description}\end{quote}

\end{fulllineitems}

\index{rand\_trough() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.rand_trough}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{rand\_trough}}{\emph{tr}, \emph{mg=False}, \emph{ztr={[}{]}}}{}
Randomly generate ellipsoid geometry parameters:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{tr}} -- Ellipsoid parameters

\item {} 
\textbf{\texttt{mg}} -- Meshgrid object

\item {} 
\textbf{\texttt{ztr}} -- Elevation of ellipsoid centre point

\end{itemize}

\item[{Returns}] \leavevmode
Length, width and depth of ellipsoid

\item[{Return type}] \leavevmode
a, b, c

\end{description}\end{quote}

\end{fulllineitems}

\index{reindex() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.reindex}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{reindex}}{\emph{inray}}{}
Reindex array from 0
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{inray}} -- Array with indices

\item[{Returns}] \leavevmode
Vectorized function of inray

\item[{Return type}] \leavevmode
vecmat

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_arrays() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.save_arrays}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{save\_arrays}}{\emph{arr\_size}, \emph{bg=False}, \emph{mat\_count=0}, \emph{ani=True}}{}
Generate arrays for material properties storage
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{arr\_size}} -- Size of array

\item {} 
\textbf{\texttt{bg}} -- List of background values for each array

\item {} 
\textbf{\texttt{ani}} (\emph{\texttt{bool}}) -- Boolean if anisotropy is to be generated

\end{itemize}

\item[{Returns}] \leavevmode
Material values
fac:                    Facies values

\item[{Return type}] \leavevmode
mat

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_models() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.save_models}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{save\_models}}{\emph{realdir}, \emph{realname}, \emph{mg}, \emph{outputs}, \emph{flowtrans}, \emph{k\_iso}, \emph{ktensors}, \emph{poros}, \emph{anirat}, \emph{dip}, \emph{azim}}{}
Save HYVR outputs to standard modelling codes
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{run}} (\emph{\texttt{dict}}) -- Model run parameters

\item {} 
\textbf{\texttt{mg}} -- Mesh grid object class

\item {} 
\textbf{\texttt{flowtrans}} (\emph{\texttt{dict}}) -- Flow \& transport simulation parameters

\item {} 
\textbf{\texttt{k\_iso}} -- Horizontal hydraulic conductivity array

\item {} 
\textbf{\texttt{ktensors}} -- Array with tensor values of K

\item {} 
\textbf{\texttt{poros}} -- Porosity array

\item {} 
\textbf{\texttt{anirat}} -- Anistropic ratio (K\_h/K\_v)

\end{itemize}

\item[{Returns}] \leavevmode
Save data outputs as .mf (MODFLOW) or .hgs (HydroGeoSphere)

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_outputs() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.save_outputs}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{save\_outputs}}{\emph{realdir}, \emph{realname}, \emph{outputs}, \emph{mg}, \emph{outdict}}{}
Save data arrays to standard formats
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{realdir}} (\emph{\texttt{str}}) -- File path to save to

\item {} 
\textbf{\texttt{realname}} (\emph{\texttt{str}}) -- File name

\item {} 
\textbf{\texttt{run}} (\emph{\texttt{dict}}) -- Model run parameters

\item {} 
\textbf{\texttt{mg}} -- Mesh grid object class

\item {} 
\textbf{\texttt{outdict}} -- Output directory

\end{itemize}

\item[{Returns}] \leavevmode
Save data outputs as .vtk (Paraview), .mat (Matlab) or .dat (Python pickle output)

\end{description}\end{quote}

\end{fulllineitems}

\index{scale\_rotate() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.scale_rotate}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{scale\_rotate}}{\emph{x}, \emph{y}, \emph{z}, \emph{alpha=0}, \emph{a=1}, \emph{b=1}, \emph{c=1}}{}
Scale and rotate three-dimensional trough
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{y, z}} (\emph{\texttt{x,}}) -- Spatial coordinates

\item {} 
\textbf{\texttt{alpha}} (\emph{\texttt{float}}) -- Rotation angle about the z-axis

\item {} 
\textbf{\texttt{b, c}} (\emph{\texttt{a,}}) -- Axis lengths in x, y, z directions (ellipsoid length, width, depth)

\end{itemize}

\item[{Returns}] \leavevmode
Grid cells within ellipsoid
R2:                             Grid of scaled and rotated values

\item[{Return type}] \leavevmode
select

\end{description}\end{quote}

\end{fulllineitems}

\index{thetaAR2() (in module hyvr.hyvr.sim)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.sim.thetaAR2}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.sim.}\sphinxbfcode{thetaAR2}}{\emph{t1}, \emph{t2}, \emph{k}, \emph{h}, \emph{eps}}{}
Implementation of AR2 autoregressive model (Ferguson, 1976, Eq.15)
\url{http://onlinelibrary.wiley.com/doi/10.1002/esp.3290010403/full}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{t1}} -- theta(i-1)

\item {} 
\textbf{\texttt{t2}} -- theta(i-2)

\item {} 
\textbf{\texttt{k}} -- Wavenumber

\item {} 
\textbf{\texttt{h}} -- Height

\item {} 
\textbf{\texttt{eps}} -- Random background noise

\end{itemize}

\item[{Returns}] \leavevmode
2nd-order autoregression (AR2)

\end{description}\end{quote}

\end{fulllineitems}



\subsection{hyvr.hyvr.utils module}
\label{hyvr:module-hyvr.hyvr.utils}\label{hyvr:hyvr-hyvr-utils-module}\index{hyvr.hyvr.utils (module)}
Some utility functions for HFM modelling
\begin{quote}\begin{description}
\item[{Authors}] \leavevmode
Jeremy P. Bennett, with help from Alessandro Comunian

\item[{Notes}] \leavevmode
\end{description}\end{quote}
\index{calc\_norm() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.calc_norm}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{calc\_norm}}{\emph{x}}{}
Calculate norm (compute the complex conjugate from `x')
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{x}} -- Input parameter

\item[{Returns}] \leavevmode
Complex conjugate of x

\end{description}\end{quote}

\end{fulllineitems}

\index{dem\_load() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.dem_load}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{dem\_load}}{\emph{fn}}{}
Load data from ESRI-style ASCII-file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{fn}} (\emph{\texttt{str}}) -- Directory and file name for save

\item[{Returns}] \leavevmode
\textbf{data} -- Data from ERSI-style ASCII-file
meta (dict):            Dict with grid metadata

\item[{Return type}] \leavevmode
numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{dem\_save() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.dem_save}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{dem\_save}}{\emph{fn}, \emph{data}, \emph{gro}}{}
Save DEM data to ESRI-style ASCII-file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{fn}} (\emph{\texttt{str}}) -- Directory and file name for save

\item {} 
\textbf{\texttt{data}} (\emph{\texttt{numpy array}}) -- DEM data

\item {} 
\textbf{\texttt{gr}} (\emph{\texttt{object class}}) -- grid.Grid() object class

\end{itemize}

\item[{Returns}] \leavevmode
Save DEM data to ESRI-style ASCII-file

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_boreholes() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.get_boreholes}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{get\_boreholes}}{\emph{bh\_loc}, \emph{fin}, \emph{fout=None}}{}
Get virtual borehole data
Returns values at centroids - this might not match the borehole inputs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{bh\_loc}} -- Location of boreholes

\item {} 
\textbf{\texttt{fin}} -- Filepath of properties input

\item {} 
\textbf{\texttt{fout}} -- Filepath to save borehole information

\end{itemize}

\item[{Returns}] \leavevmode
X, Y values at centroids

\item[{Return type}] \leavevmode
bhdf

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_gslib() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.load_gslib}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{load\_gslib}}{\emph{fn}}{}
Load .gslib files. This has been appropriated from the HPGL library
\url{https://github.com/hpgl/hpgl/blob/master/src/geo\_bsd/routines.py}
commit b980e15ad9b1f7107fd4fa56ab117f45553be3aa
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{fn}} (\emph{\texttt{str}}) -- .gslib file path and name

\item[{Returns}] \leavevmode
\textbf{gslib\_dict} -- properties

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_pickle() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.load_pickle}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{load\_pickle}}{\emph{pickfile}}{}
Pickle input file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pickfile}} -- Input file

\item[{Returns}] \leavevmode
\textbf{data} -- Pickled data of input file

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{matlab\_save() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.matlab_save}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{matlab\_save}}{\emph{fn}, \emph{data}}{}
Save numpy array to .mat file for use in matlab.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{fn}} (\emph{\texttt{str}}) -- File name (ending with .mat)

\item {} 
\textbf{\texttt{data}} (\emph{\texttt{numpy array}}) -- Data to save

\end{itemize}

\item[{Returns}] \leavevmode
Save a dictionary of names and arrays into a MATLAB-style .mat file.
This saves the array objects in the given dictionary to a MATLAB- style .mat file.

\end{description}\end{quote}

\end{fulllineitems}

\index{model\_setup() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.model_setup}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{model\_setup}}{\emph{pf}}{}
Set up model using grid.Grid() class and assign parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pf}} (\emph{\texttt{str}}) -- Parameter file path

\item[{Returns}] \leavevmode
\textbf{run} -- Model run parameters
mod (dict):                     Model domain parameters
sequences (dict):               Sequence parameters
hydraulics (dict):              Hydraulic properties parameters
flowtrans (dict):               Flow \& transport simulation parameters
elements (dict):                Architectural elements and parameters
model\_grid (object class):      Grid object class

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{parameters() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.parameters}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{parameters}}{\emph{file\_in}}{}
Get parameters for hierarchical facies modelling
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{file\_in}} (\emph{\texttt{str}}) -- Parameter file path

\item[{Returns}] \leavevmode
\textbf{run} -- Model run parameters
model (dict):           Model domain parameters
sequences (dict):       Sequence parameters
hydraulics (dict):      Hydraulic properties parameters
flowtrans (dict):       Flow \& transport simulation parameters
elements (dict):        Architectural elements and parameters

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_lu() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.read_lu}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{read\_lu}}{\emph{sq\_fp}}{}
Load user-defined sequences (architectural element lookup table),
split the data based on a delimiter and return it as a new list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{sq\_fp}} -- Load user-defined sequences (architectural element lookup table)

\item[{Returns}] \leavevmode
\textbf{seq\_lu} -- Values of architectural element lookup table

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{rotate\_ktensor() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.rotate_ktensor}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{rotate\_ktensor}}{\emph{count}, \emph{aniso}, \emph{azimuth}, \emph{dip}, \emph{k\_in}}{}
Create a rotated K tensor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{count}} (\emph{\texttt{int}}) -- Material number and/or identifier

\item {} 
\textbf{\texttt{aniso}} -- Anisotropy

\item {} 
\textbf{\texttt{azimuth}} -- Azimuth angles

\item {} 
\textbf{\texttt{dip}} -- Dipping angles

\item {} 
\textbf{\texttt{k\_in}} -- \begin{itemize}
\item {} 
\end{itemize}


\end{itemize}

\item[{Returns}] \leavevmode
Rotated K tensor

\item[{Return type}] \leavevmode
k\_rotate

\end{description}\end{quote}

\end{fulllineitems}

\index{round\_x() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.round_x}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{round\_x}}{\emph{x}, \emph{base=1}, \emph{prec=2}}{}
Round to the nearest z-increment (Refer to \url{http://stackoverflow.com/questions/2272149/round-to-5-or-other-number-in-python})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} (\emph{\texttt{float}}) -- Input parameter

\item {} 
\textbf{\texttt{base}} (\emph{\texttt{int}}) -- Base parameter for avoiding floating-point values

\item {} 
\textbf{\texttt{prec}} -- Precision of rounding

\end{itemize}

\item[{Returns}] \leavevmode
Rounded value of nearest z-increment

\end{description}\end{quote}

\end{fulllineitems}

\index{specsim() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.specsim}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{specsim}}{\emph{gr}, \emph{var}, \emph{corl}, \emph{twod=False}, \emph{covmod='gau'}}{}
Generate random variables stationary covariance function using spectral techniques of Dietrich \& Newsam (1993)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{gr}} -- Grid class object

\item {} 
\textbf{\texttt{var}} -- Variance

\item {} 
\textbf{\texttt{corl}} -- Tuple of correlation length of random variable

\item {} 
\textbf{\texttt{twod}} -- Flag for two-dimensional simulation

\item {} 
\textbf{\texttt{covmod}} -- Which covariance model to use
`gau': Gaussian
`exp': Exponential

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{Random gaussian variable}] \leavevmode
Real part of a complex array, created via inverse discrete Fourier Transform

\end{description}


\item[{Return type}] \leavevmode
bigy

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_hgs() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.to_hgs}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{to\_hgs}}{\emph{hgspath}, \emph{mg}, \emph{flowtrans}, \emph{ktensors}, \emph{poros}}{}
Convert HYVR outputs to HydroGeoSphere inputs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{hgspath}} (\emph{\texttt{str}}) -- Path where to save HGS output file

\item {} 
\textbf{\texttt{ktensors}} -- Array with tensor values of K

\item {} 
\textbf{\texttt{poros}} -- Array with values of porosity

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{val\_fmts} -- Dictionary with values of K tensor and porosity
val\_filepath:           file name of HGS output file

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_mf6() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.to_mf6}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{to\_mf6}}{\emph{mfdir}, \emph{runname}, \emph{mg}, \emph{flowtrans}, \emph{k\_iso}, \emph{anirat}, \emph{dip}, \emph{azim}}{}~
Convert HYVR outputs to MODFLOW6 inputs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{mfdir}} -- Directory of MODFLOW model object

\item {} 
\textbf{\texttt{runname}} -- Run name

\item {} 
\textbf{\texttt{mg}} -- Mesh grid object class

\item {} 
\textbf{\texttt{flowtrans}} (\emph{\texttt{dict}}) -- Flow \& transport simulation parameters

\item {} 
\textbf{\texttt{k\_iso}} -- Hydraulic conductivity of HYVR

\item {} 
\textbf{\texttt{anirat}} -- Background anistropic ratio (K\_h/K\_v anisotropy ratio)

\end{itemize}

\item[{Returns}] \leavevmode
MODFLOW model object
dis:                            Discretization of modflow object
bas:                            BAS package of modflow model
lpf:                            LPF package of modflow model
oc:                                     OC package of modflow model
pcg:                            pcg package of modflow model

\item[{Return type}] \leavevmode
mf

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_modflow() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.to_modflow}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{to\_modflow}}{\emph{mfdir}, \emph{mg}, \emph{flowtrans}, \emph{k\_iso}, \emph{anirat}}{}
Convert HYVR outputs to MODFLOW inputs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{mfdir}} -- Directory of MODFLOW model object

\item {} 
\textbf{\texttt{mg}} -- Mesh grid object class

\item {} 
\textbf{\texttt{flowtrans}} (\emph{\texttt{dict}}) -- Flow \& transport simulation parameters

\item {} 
\textbf{\texttt{k\_iso}} -- Hydraulic conductivity of HYVR

\item {} 
\textbf{\texttt{anirat}} -- Background anistropic ratio (K\_h/K\_v anisotropy ratio)

\end{itemize}

\item[{Returns}] \leavevmode
MODFLOW model object
dis:                            Discretization of modflow object
bas:                            BAS package of modflow model
lpf:                            LPF package of modflow model
oc:                                     OC package of modflow model
pcg:                            pcg package of modflow model

\item[{Return type}] \leavevmode
mf

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_vtk() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.to_vtk}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{to\_vtk}}{\emph{data}, \emph{file\_name}, \emph{grid=None}, \emph{sc\_name=None}}{}
Save a numpy array into a VTK STRUCTURED\_POINTS file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{numpy array}}) -- Numpy array containing the data, \sphinxtitleref{int} or \sphinxtitleref{float} or \sphinxtitleref{uint}.
The dimensions should be between 1 and 3

\item {} 
\textbf{\texttt{file\_name}} (\emph{\texttt{string}}) -- Name of the file for the output, optional (None)

\item {} 
\textbf{\texttt{grid}} (\emph{\texttt{class Grid}}) -- Information about the grid can be also provided as a Grid object

\item {} 
\textbf{\texttt{sc\_name}} (\emph{\texttt{string}}) -- Name of the scalar quantities

\end{itemize}

\item[{Returns}] \leavevmode

A VTK `STRUCTURED\_POINTS' dataset file containing the input numpy data.


\end{description}\end{quote}

\end{fulllineitems}

\index{to\_vtr() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.to_vtr}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{to\_vtr}}{\emph{data\_dict}, \emph{file\_name}, \emph{grid}}{}
Save a numpy array into a \sphinxcode{.vtr} rectilinear grid of voxels using pyevtk
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data\_dict}} (\emph{\texttt{numpy array}}) -- e.g. \{`fac': fac, `mat': mat\}

\item {} 
\textbf{\texttt{file\_name}} (\emph{\texttt{string}}) -- Name of the file for the output.

\item {} 
\textbf{\texttt{grid}} (\emph{\texttt{class Grid}}) -- The information about the grid can be also provided as a grid object.

\end{itemize}

\item[{Returns}] \leavevmode

A VTK STRUCTURED\_POINTS dataset file containing the input numpy data.


\end{description}\end{quote}

\end{fulllineitems}

\index{try\_makefolder() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.try_makefolder}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{try\_makefolder}}{\emph{makedir}}{}
Create modflow output folder

\end{fulllineitems}

\index{vtk\_mask() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.vtk_mask}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{vtk\_mask}}{\emph{data}, \emph{out\_name}, \emph{mask\_val=-15}, \emph{grid=None}}{}
Prepare a mask file from a \sphinxcode{vtk} input. All values should be 0 or 1 after this operation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{numpy array}}) -- Data to replace

\item {} 
\textbf{\texttt{out\_name}} (\emph{\texttt{string}}) -- Name of the file for the output.

\item {} 
\textbf{\texttt{mask\_val}} (\emph{\texttt{int}}) -- Value of the facies which should be masked

\item {} 
\textbf{\texttt{grid}} -- Grid class

\end{itemize}

\item[{Returns}] \leavevmode
A VTK `STRUCTURED\_POINTS' dataset file containing the mask data

\end{description}\end{quote}

\end{fulllineitems}

\index{vtk\_read() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.vtk_read}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{vtk\_read}}{\emph{file\_in}}{}
Reads a \sphinxcode{.vtk} file into a numpy array
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{file\_in}} (\emph{\texttt{str}}) -- Name and filepath to read

\item[{Returns}] \leavevmode
\textbf{gegrid} -- Grid class
props (numpy array):            Grid properties

\item[{Return type}] \leavevmode
hyvr.grid class

\end{description}\end{quote}

\end{fulllineitems}

\index{vtk\_trim() (in module hyvr.hyvr.utils)}

\begin{fulllineitems}
\phantomsection\label{hyvr:hyvr.hyvr.utils.vtk_trim}\pysiglinewithargsret{\sphinxcode{hyvr.hyvr.utils.}\sphinxbfcode{vtk\_trim}}{\emph{file\_in}, \emph{dims}, \emph{file\_out=None}}{}
Trims a vtk file to the desired dimensions.
Removes the effort of working out the indexing in a .grdecl file
Saves as a .vtk file with everything the same except the dimensions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{file\_in}} -- .vtk file to trim

\item {} 
\textbf{\texttt{dims}} -- 3-tuple of dimensions

\item {} 
\textbf{\texttt{file\_out}} -- Output file

\end{itemize}

\item[{Returns}] \leavevmode

Grid class of the data
props:          The data as a nx x ny x nz array
\begin{description}
\item[{...notes:}] \leavevmode\begin{itemize}
\item {} 
Number of cells (nx, ny, nz) is changed

\item {} 
Spacing (dx, dy, dz) is NOT changed

\end{itemize}

\end{description}


\item[{Return type}] \leavevmode
gegrid

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Module contents}
\label{hyvr:module-contents}\label{hyvr:module-hyvr.hyvr}\index{hyvr.hyvr (module)}

\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\begin{thebibliography}{BHC17}
\bibitem[BHC17]{BHC17}{\phantomsection\label{references:bennett2017} 
Jeremy Bennett, Claus P. Haslauer, and Olaf A. Cirpka. The impact of sedimentary anisotropy on solute mixing in stacked scour-pool structures. \emph{Water Resources Research}, 53(4):2813–2832, April 2017. \href{https://doi.org/10.1002/2016WR019665}{doi:10.1002/2016WR019665}.
}
\bibitem[DN93]{DN93}{\phantomsection\label{references:dietrich1993} 
C. R. Dietrich and G. N. Newsam. A fast and exact method for multidimensional gaussian stochastic simulations. \emph{Water Resources Research}, 29(8):2861–2869, August 1993. \href{https://doi.org/10.1029/93WR01070}{doi:10.1029/93WR01070}.
}
\bibitem[Fer76]{Fer76}{\phantomsection\label{references:ferguson1976} 
R. I. Ferguson. Disturbed periodic model for river meanders. \emph{Earth Surface Processes}, 1(4):337–347, October 1976. \href{https://doi.org/10.1002/esp.3290010403}{doi:10.1002/esp.3290010403}.
}
\bibitem[JSD94]{JSD94}{\phantomsection\label{references:jussel1994} 
Peter Jussel, Fritz Stauffer, and Themistocles Dracos. Transport modeling in heterogeneous aquifers: 1. Statistical description and numerical generation of gravel deposits. \emph{Water Resources Research}, 30(6):1803–1817, June 1994. \href{https://doi.org/10.1029/94WR00162}{doi:10.1029/94WR00162}.
}
\end{thebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{h}
\item {\texttt{hyvr.hyvr}}, \pageref{hyvr:module-hyvr.hyvr}
\item {\texttt{hyvr.hyvr.grid}}, \pageref{hyvr:module-hyvr.hyvr.grid}
\item {\texttt{hyvr.hyvr.sim}}, \pageref{hyvr:module-hyvr.hyvr.sim}
\item {\texttt{hyvr.hyvr.utils}}, \pageref{hyvr:module-hyvr.hyvr.utils}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
