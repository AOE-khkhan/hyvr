

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>hyvr.hyvr &#8212; HYVR 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/bizstyle.js"></script>
    <link rel="top" title="HYVR 0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">HYVR 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../methods.html">HYVR Computational methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../inout.html">HYVR inputs and outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example.html">HYVR Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../more.html">Extending HyVR</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">hyvr</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for hyvr.hyvr</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot; Hydrogeological Virtual Reality simulation package.</span>

<span class="sd">    Hydrogeological virtual reality (HYVR) simulator for object-based modelling of sedimentary structures</span>

<span class="sd">    Notes:</span>
<span class="sd">         Grid nodes are cell-centred!</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">st</span>
<span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="nn">sio</span>
<span class="kn">import</span> <span class="nn">hyvr.hyvr_utils</span> <span class="k">as</span> <span class="nn">hu</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">hyvr.grid</span> <span class="k">as</span> <span class="nn">gr</span>


<div class="viewcode-block" id="hyvr_main"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.hyvr_main">[docs]</a><span class="k">def</span> <span class="nf">hyvr_main</span><span class="p">(</span><span class="n">param_file</span><span class="p">,</span> <span class="n">hs</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Main function for HYVR generation</span>

<span class="sd">    Args:</span>
<span class="sd">        param_file (str):   Parameter file location</span>
<span class="sd">        hs</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Load parameter file</span>
    <span class="n">run</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">sequences</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">,</span> <span class="n">flowtrans</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">mg</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">model_setup</span><span class="p">(</span><span class="n">param_file</span><span class="p">)</span>
    <span class="n">hfm_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="s2">&quot;..&quot;</span><span class="p">))</span>     <span class="c1"># Get HFM directory location</span>
    <span class="n">rundir</span> <span class="o">=</span> <span class="n">hfm_dir</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">runfiles</span><span class="se">\\</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">hs</span><span class="p">:</span>
        
        <span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">        Simulate sequence contacts</span>
<span class="sd">        --------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;l_seq&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot; Create contact surfaces &quot;&quot;&quot;</span>
            <span class="n">z_bot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span>
            <span class="n">seq_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># Initialise sequence storage array</span>
            <span class="n">seq_top_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;l_seq&#39;</span><span class="p">])))</span>
            <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_seq_bot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;l_seq&#39;</span><span class="p">])</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">zzz</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">meshup</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">seqi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;l_seq&#39;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">si</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">si_bot</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">si_bot</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_seq_top&#39;</span><span class="p">][</span><span class="n">si</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">si_top</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_seq_top&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">])</span>
                <span class="n">seq_arr</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">si_bot</span><span class="p">:</span><span class="n">si_top</span><span class="p">]</span> <span class="o">=</span> <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_bg&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span>            <span class="c1"># Assign background facies to sequence</span>
                <span class="k">if</span> <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;seq_contact&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span> <span class="ow">and</span> <span class="n">si</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;l_seq&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sp</span> <span class="o">=</span> <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;ll_seq_contact_model&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span>       <span class="c1"># geostatistical parameters of sequence</span>

                    <span class="c1"># Generate random top contact</span>
                    <span class="n">z_top</span> <span class="o">=</span> <span class="n">specsim</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sp</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">twod</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_seq_top&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span>
                    <span class="n">z_top</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">round_x</span><span class="p">(</span><span class="n">z_top</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">model</span><span class="p">[</span><span class="s1">&#39;dz&#39;</span><span class="p">])</span>           <span class="c1"># round the values to grid resolution</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Flat top contact</span>
                    <span class="n">z_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span> <span class="o">*</span> <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_seq_top&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span>

                <span class="c1"># Update lowest and highest values due to randomness</span>
                <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_seq_bot&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z_bot</span><span class="p">),</span> <span class="n">mg</span><span class="o">.</span><span class="n">oz</span><span class="p">])</span>
                <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_seq_top&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z_top</span><span class="p">),</span> <span class="n">mg</span><span class="o">.</span><span class="n">oz</span> <span class="o">+</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">])</span>

                <span class="c1"># Assign z_bot and z_top values to entire array</span>
                <span class="n">z_bot_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">z_bot</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">])</span>
                <span class="n">z_top_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">z_top</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">])</span>
                <span class="n">zae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">zzz</span> <span class="o">&gt;=</span> <span class="n">z_bot_arr</span><span class="p">,</span> <span class="n">zzz</span> <span class="o">&lt;</span> <span class="n">z_top_arr</span><span class="p">)</span>
                <span class="n">seq_arr</span><span class="p">[</span><span class="n">zae</span><span class="p">]</span> <span class="o">=</span> <span class="n">si</span>

                <span class="n">z_bot</span> <span class="o">=</span> <span class="n">z_top</span>                   <span class="c1"># Update lower contact surface elevation</span>
                <span class="n">seq_top_z</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_top</span>     <span class="c1"># Assign sequence top to storage array</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Only one sequence present</span>
            <span class="n">seq_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># Initialise sequence storage array</span>
            <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_seq_bot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">mg</span><span class="o">.</span><span class="n">oz</span><span class="p">]</span>
            <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_seq_top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">mg</span><span class="o">.</span><span class="n">oz</span> <span class="o">+</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">]</span>
            
        <span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">        Simulate architectural element units</span>
<span class="sd">        --------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;ae_table&#39;</span> <span class="ow">in</span> <span class="n">sequences</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot; Load architectural element lookup table &quot;&quot;&quot;</span>
            <span class="n">ae_lu</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">read_lu</span><span class="p">(</span><span class="n">rundir</span><span class="p">,</span> <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;ae_table&#39;</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;ll_ae_z_mean&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot; Uniform Model &quot;&quot;&quot;</span>
            <span class="n">ae_lu</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">,</span> <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;ll_seq_ae&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]]]</span>
            <span class="n">ae_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># Initialise sequence storage array</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot; Assign architectural element units &quot;&quot;&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: Generating architectural element unit contacts&#39;</span><span class="p">)</span>

            <span class="c1"># Initialise architectural element unit lookup table</span>
            <span class="c1"># [architectural element unit #, z_bottom, z_top, architectural element type, sequence #</span>
            <span class="n">ae_lu</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">seqi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;l_seq&#39;</span><span class="p">]):</span>
                <span class="c1"># Randomly assign sequences / architectural element contact surfaces</span>
                <span class="n">znow</span> <span class="o">=</span> <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_seq_bot&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span>
                <span class="k">while</span> <span class="n">znow</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">,</span> <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_seq_top&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]]):</span>
                    <span class="c1"># Loop over all depths in sequence</span>
                    <span class="c1"># Get</span>
                    <span class="n">aelu_z</span> <span class="o">=</span> <span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="n">znow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">si</span><span class="p">]</span>       <span class="c1"># Initialise AE entry in lookup table (and assign identifier)</span>

                    <span class="c1"># Assign architectural element</span>
                    <span class="n">aelu_z</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob_choose</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;ll_seq_ae&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">],</span>
                                            <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;ll_ae_prob&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">])</span>

                    <span class="c1"># Assign sequence thickness</span>
                    <span class="n">ae_z_mean</span> <span class="o">=</span> <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;ll_ae_z_mean&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">][</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;ll_seq_ae&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">aelu_z</span><span class="p">[</span><span class="mi">3</span><span class="p">])]</span>
                    <span class="n">ae_z</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">round_x</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">ae_z_mean</span><span class="p">,</span> <span class="n">ae_z_mean</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">base</span><span class="o">=</span><span class="n">model</span><span class="p">[</span><span class="s1">&#39;dz&#39;</span><span class="p">])</span>
                    <span class="n">aelu_z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ae_z</span> <span class="o">+</span> <span class="n">znow</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">)</span>

                    <span class="c1"># Assign avulsion</span>
                    <span class="n">avul_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;ll_avul_prob&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">])</span>
                    <span class="n">yn</span> <span class="o">=</span> <span class="n">prob_choose</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">avul_prob</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">avul_prob</span><span class="p">])</span>         <span class="c1"># Avulsion yes/no</span>
                    <span class="n">avudr</span> <span class="o">=</span> <span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;ll_avul&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span>      <span class="c1"># Avulsion depth range for sequence</span>
                    <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">avudr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">avudr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">yn</span>
                    <span class="n">znow</span> <span class="o">+=</span> <span class="n">ae_z</span> <span class="o">+</span> <span class="n">dz</span>

                    <span class="c1"># Append to lookup table</span>
                    <span class="n">ae_lu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aelu_z</span><span class="p">)</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="sd">&quot;&quot;&quot; Create contact surfaces &quot;&quot;&quot;</span>
        <span class="n">z_bot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span>
        <span class="n">ae_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># Initialise sequence storage array</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">zzz</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">meshup</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">ae_i</span><span class="p">,</span> <span class="n">ae_z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ae_lu</span><span class="p">):</span>
            <span class="n">ae_dict</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">ae_z</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
            <span class="k">if</span> <span class="s1">&#39;contact&#39;</span> <span class="ow">in</span> <span class="n">ae_dict</span> <span class="ow">and</span> <span class="n">ae_dict</span><span class="p">[</span><span class="s1">&#39;contact&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ae_i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ae_lu</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># If AE unit is the upper-most in the domain</span>
                    <span class="n">z_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span> <span class="o">*</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span>
                <span class="k">elif</span> <span class="n">ae_lu</span><span class="p">[</span><span class="n">ae_i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ae_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="s1">&#39;ae_table&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sequences</span><span class="p">:</span>
                    <span class="c1"># Use the sequence top contact if the AE unit is the top-most in the sequence</span>
                    <span class="n">z_top</span> <span class="o">=</span> <span class="n">seq_top_z</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ae_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Generate random top contact</span>
                    <span class="n">sp</span> <span class="o">=</span> <span class="n">ae_dict</span><span class="p">[</span><span class="s1">&#39;r_contact_model&#39;</span><span class="p">]</span>
                    <span class="n">z_top</span> <span class="o">=</span> <span class="n">specsim</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sp</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">twod</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="n">ae_z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">z_top</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">round_x</span><span class="p">(</span><span class="n">z_top</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">model</span><span class="p">[</span><span class="s1">&#39;dz&#39;</span><span class="p">])</span>           <span class="c1"># round the values to grid resolution</span>
                    <span class="n">ae_z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z_top</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Flat top contact</span>
                <span class="n">z_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span> <span class="o">*</span> <span class="n">ae_z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># Assign z_bot and z_top values to entire array</span>
            <span class="n">z_bot_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">z_bot</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">])</span>
            <span class="n">z_top_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">z_top</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">])</span>
            <span class="n">zae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">zzz</span> <span class="o">&gt;=</span> <span class="n">z_bot_arr</span><span class="p">,</span> <span class="n">zzz</span> <span class="o">&lt;</span> <span class="n">z_top_arr</span><span class="p">)</span>
            <span class="n">zae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">zae</span><span class="p">,</span> <span class="n">seq_arr</span> <span class="o">==</span> <span class="n">ae_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ae_arr</span><span class="p">[</span><span class="n">zae</span><span class="p">]</span> <span class="o">=</span> <span class="n">ae_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">z_bot</span> <span class="o">=</span> <span class="n">z_top</span>           <span class="c1"># Update lower contact surface elevation</span>

        <span class="c1"># Save sequence lookup table</span>
        <span class="c1"># if &#39;ae_table&#39; not in sequences:</span>
        <span class="c1">#     lu_savetxt = rundir + &#39;/ae_lu_&#39; + time.strftime(&#39;%d-%m-%Y_%H.%M.%S.txt&#39;)</span>
        <span class="c1">#     with open(lu_savetxt, &#39;w&#39;) as fwr:</span>
        <span class="c1">#         print(&#39;Sequences summary&#39;)</span>
        <span class="c1">#         for i in ae_lu:</span>
        <span class="c1">#             fwr.write(&#39;%s\n&#39; % str()[1:-1])</span>
        <span class="c1">#             print(i)</span>

        <span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">        Hydrofacies simulation</span>
<span class="sd">        --------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>
        <span class="c1"># Initialise storage arrays</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">mat</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="n">azim</span><span class="p">,</span> <span class="n">dip</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">bg</span><span class="o">=</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_bg&#39;</span><span class="p">],</span> <span class="n">mat_count</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>

        <span class="sd">&quot;&quot;&quot; Create architectural elements and associated hydrofacies fields &quot;&quot;&quot;</span>
        <span class="c1"># Loop over AE units rather than elevations</span>
        <span class="k">for</span> <span class="n">ae_i</span> <span class="ow">in</span> <span class="n">ae_lu</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: generating &#39;</span> <span class="o">+</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; from &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ae_i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;m&#39;</span><span class="p">)</span>
            <span class="n">ae_dict</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">ae_i</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">ae_dict</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;trunc_ellip&#39;</span><span class="p">:</span>
                <span class="c1"># Generate truncated ellipsoid</span>
                <span class="n">props_n</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">gen_trough</span><span class="p">(</span><span class="n">ae_dict</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">ae_i</span><span class="p">,</span> <span class="n">ae_arr</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
                <span class="n">ae_mask</span> <span class="o">=</span> <span class="n">props_n</span><span class="p">[</span><span class="s1">&#39;ae_arr_i&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ae_arr</span><span class="p">[</span><span class="n">ae_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">ae_dict</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;channel&#39;</span><span class="p">:</span>
                <span class="c1"># Generate channel</span>
                <span class="n">props_n</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">gen_channel</span><span class="p">(</span><span class="n">ae_dict</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">ae_i</span><span class="p">,</span> <span class="n">ae_arr</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
                <span class="n">ae_mask</span> <span class="o">=</span> <span class="n">props_n</span><span class="p">[</span><span class="s1">&#39;ae_arr_i&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ae_arr</span><span class="p">[</span><span class="n">ae_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">ae_dict</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;sheet&#39;</span><span class="p">:</span>
                <span class="c1"># Generate sheet</span>
                <span class="n">props_n</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">gen_sheet</span><span class="p">(</span><span class="n">ae_dict</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">ae_i</span><span class="p">,</span> <span class="n">ae_arr</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
                <span class="n">ae_mask</span> <span class="o">=</span> <span class="n">ae_arr</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Assign simulated values to storage arrays</span>
            <span class="n">mat</span><span class="p">[</span><span class="n">ae_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">props_n</span><span class="p">[</span><span class="s1">&#39;mat&#39;</span><span class="p">][</span><span class="n">ae_mask</span><span class="p">]</span>
            <span class="n">fac</span><span class="p">[</span><span class="n">ae_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">props_n</span><span class="p">[</span><span class="s1">&#39;fac&#39;</span><span class="p">][</span><span class="n">ae_mask</span><span class="p">]</span>
            <span class="n">azim</span><span class="p">[</span><span class="n">ae_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">props_n</span><span class="p">[</span><span class="s1">&#39;azim&#39;</span><span class="p">][</span><span class="n">ae_mask</span><span class="p">]</span>
            <span class="n">dip</span><span class="p">[</span><span class="n">ae_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">props_n</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">][</span><span class="n">ae_mask</span><span class="p">]</span>

        <span class="c1"># Wrap storage arrays in a dictionary</span>
        <span class="k">if</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;flag_anisotropy&#39;</span><span class="p">]:</span>
            <span class="n">props</span> <span class="o">=</span> <span class="p">[</span><span class="n">azim</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">fac</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">props</span> <span class="o">=</span> <span class="p">[</span><span class="n">mat</span><span class="p">,</span> <span class="n">fac</span><span class="p">]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">run</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">,</span> <span class="n">flowtrans</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">mg</span><span class="p">]</span>

        <span class="c1"># Renumber material values from zero to remove eroded values</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">reindex</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;-------------------------------------------------------------------------------------------------------------</span>
<span class="sd">    Assignment of hydraulic parameters</span>
<span class="sd">    --------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>
    <span class="c1"># if hydraulics:</span>

    <span class="c1"># -------------------------------------------------------------------------------------------------------------</span>
    <span class="c1"># TESTING ONLY!!# TESTING ONLY!!# TESTING ONLY!!</span>
    <span class="k">if</span> <span class="n">hs</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;scratch/trough_props.npz&#39;</span><span class="p">)</span>
        <span class="n">fac</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;fac&#39;</span><span class="p">]</span>
        <span class="n">dip</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">]</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mat&#39;</span><span class="p">]</span>
        <span class="n">azim</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;azim&#39;</span><span class="p">]</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;scratch/trough_seq.npz&#39;</span><span class="p">)</span>
        <span class="n">ae_arr</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ae_arr&#39;</span><span class="p">]</span>
        <span class="n">ae_lu</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ae_lu&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
     <span class="c1"># -------------------------------------------------------------------------------------------------------------</span>

    <span class="sd">&quot;&quot;&quot; Assignment of heterogeneity</span>
<span class="sd">            - If run[&#39;flag_hetero&#39;] is false then hydrofacies are homogeneous</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: generating hydraulic parameters&#39;</span><span class="p">)</span>

    <span class="c1"># Initialise storage arrays</span>
    <span class="n">k_iso</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>       <span class="c1"># Horizontal hydraulic conductivity array</span>
    <span class="n">poros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>       <span class="c1"># Porosity array</span>
    <span class="n">anirat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>       <span class="c1"># K_h/K_v anisotropy ratio</span>

    <span class="k">if</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;flag_het&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Heterogeneous case</span>
        <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">fac</span><span class="p">[</span><span class="n">mat</span> <span class="o">==</span> <span class="n">mi</span><span class="p">]):</span>
                <span class="n">mifi</span> <span class="o">=</span> <span class="p">(</span><span class="n">mat</span> <span class="o">==</span> <span class="n">mi</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fac</span> <span class="o">==</span> <span class="n">fi</span><span class="p">)</span>    <span class="c1"># Get mask for relevant values</span>

                <span class="k">if</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;hetlev&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
                    <span class="c1"># Generate internal heterogeneity</span>
                    <span class="c1"># Find outer limit of facies</span>
                    <span class="n">fac_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mifi</span><span class="p">)</span>                                <span class="c1"># Get indices of facies</span>
                    <span class="n">fac_nx</span> <span class="o">=</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>        <span class="c1"># Get number of grid cells in x-direction</span>
                    <span class="n">fac_ny</span> <span class="o">=</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>        <span class="c1"># Get number of grid cells in y-direction</span>
                    <span class="n">fac_nz</span> <span class="o">=</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>        <span class="c1"># Get number of grid cells in z-direction</span>

                    <span class="c1"># Generate field with matching size</span>
                    <span class="c1"># Should include a condition that considers the characteristic lengths of the features</span>
                    <span class="n">temp_gr</span> <span class="o">=</span> <span class="n">gr</span><span class="o">.</span><span class="n">Grid</span><span class="p">(</span><span class="n">dx</span><span class="o">=</span><span class="n">mg</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="n">mg</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="o">=</span><span class="n">mg</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">fac_nx</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">fac_ny</span><span class="p">,</span> <span class="n">nz</span><span class="o">=</span><span class="n">fac_nz</span><span class="p">,</span> <span class="n">gtype</span><span class="o">=</span><span class="s1">&#39;cells&#39;</span><span class="p">)</span>

                    <span class="c1"># Generate internal heterogeneity - hydraulic conductivity</span>
                    <span class="n">temp_k_small</span> <span class="o">=</span> <span class="n">specsim</span><span class="p">(</span><span class="n">temp_gr</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_sig_y&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">],</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;ll_ycorlengths&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">])</span>
                    <span class="n">temp_k_small</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">temp_k_small</span><span class="p">)</span> <span class="o">*</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_k_h&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>          <span class="c1"># back-transform from log space</span>
                    <span class="n">temp_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

                    <span class="c1"># Nest smaller array into larger array</span>
                    <span class="c1"># Get coordinates for &#39;nesting&#39;</span>
                    <span class="n">ix1</span> <span class="o">=</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k_small</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">iy1</span> <span class="o">=</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="n">iy2</span> <span class="o">=</span> <span class="n">iy1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k_small</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">iz1</span> <span class="o">=</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="n">iz2</span> <span class="o">=</span> <span class="n">iz1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k_small</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">iy1</span><span class="p">:</span><span class="n">iy2</span><span class="p">,</span> <span class="n">iz1</span><span class="p">:</span><span class="n">iz2</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k_small</span><span class="p">):</span>
                        <span class="c1"># QnD way to avoid indexing issues with nesting of the random field</span>
                        <span class="n">iz1</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">iz2</span> <span class="o">-=</span> <span class="mi">1</span>

                    <span class="c1"># Insert into full-size array</span>
                    <span class="n">temp_k</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">iy1</span><span class="p">:</span><span class="n">iy2</span><span class="p">,</span> <span class="n">iz1</span><span class="p">:</span><span class="n">iz2</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_k_small</span>
                    <span class="n">k_iso</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_k</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span>

                    <span class="c1"># Generate internal heterogeneity - porosity</span>
                    <span class="n">temp_n_small</span> <span class="o">=</span> <span class="n">specsim</span><span class="p">(</span><span class="n">temp_gr</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_sig_n&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">],</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;ll_ncorlengths&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">])</span> <span class="o">+</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_n&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>
                    <span class="n">temp_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                    <span class="c1"># Nest smaller array into larger array</span>
                    <span class="n">temp_n</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">iy1</span><span class="p">:</span><span class="n">iy2</span><span class="p">,</span> <span class="n">iz1</span><span class="p">:</span><span class="n">iz2</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_n_small</span>
                    <span class="n">poros</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_n</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span>

                <span class="k">elif</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;hetlev&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;facies&#39;</span><span class="p">:</span>
                    <span class="c1"># Assign heterogeneity at facies level only</span>
                    <span class="n">k_iso</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_k_h&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>
                    <span class="n">poros</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_n&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>

                <span class="c1"># Assign anisotropy ratio</span>
                <span class="n">anirat</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_k_ratio&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>

        <span class="sd">&quot;&quot;&quot; Assign background heterogeneity per architectural element &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;hetlev&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">aei</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ae_lu</span><span class="p">):</span>
                <span class="n">m0</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="n">ms</span> <span class="o">=</span> <span class="n">ae_arr</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">aei</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">aemask</span> <span class="o">=</span> <span class="n">m0</span> <span class="o">&amp;</span> <span class="n">ms</span>     <span class="c1"># Get material that equals zero within in architectural element</span>
                <span class="k">if</span> <span class="s1">&#39;r_bg&#39;</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]]:</span>
                    <span class="n">aebackfac</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="s1">&#39;r_bg&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>   <span class="c1"># architectural element background facies</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aebackfac</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="s1">&#39;r_bg&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># Assign background material</span>
                <span class="n">temp_k</span> <span class="o">=</span> <span class="n">specsim</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_sig_y&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">],</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;ll_ycorlengths&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">])</span>
                <span class="n">temp_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">temp_k</span><span class="p">)</span> <span class="o">*</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_k_h&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">]</span>          <span class="c1"># back-transform from log space</span>
                <span class="n">k_iso</span><span class="p">[</span><span class="n">aemask</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_k</span><span class="p">[</span><span class="n">aemask</span><span class="p">]</span>

                <span class="c1"># Generate internal heterogeneity - porosity</span>
                <span class="n">temp_n</span> <span class="o">=</span> <span class="n">specsim</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_sig_n&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">],</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;ll_ncorlengths&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">])</span>
                <span class="n">temp_n</span> <span class="o">=</span> <span class="n">temp_n</span> <span class="o">+</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_n&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">]</span>
                <span class="n">poros</span><span class="p">[</span><span class="n">aemask</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_n</span><span class="p">[</span><span class="n">aemask</span><span class="p">]</span>

                <span class="c1"># Assign background anistropic ratio</span>
                <span class="n">anirat</span><span class="p">[</span><span class="n">aemask</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_k_ratio&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">]</span>

        <span class="sd">&quot;&quot;&quot; Assign trends to hydraulic parameters globally &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;r_k_ztrend&#39;</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="ow">or</span> <span class="s1">&#39;r_k_xtrend&#39;</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]]:</span>
            <span class="k">if</span> <span class="s1">&#39;k_trend&#39;</span> <span class="ow">in</span> <span class="n">hydraulics</span> <span class="ow">and</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_trend&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;global&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;r_k_ztrend&#39;</span> <span class="ow">in</span> <span class="n">hydraulics</span><span class="p">:</span>
                    <span class="n">zf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_k_ztrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_k_ztrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">)</span>  <span class="c1"># Z factor at each elevation</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">zf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>

                <span class="k">if</span> <span class="s1">&#39;r_k_xtrend&#39;</span> <span class="ow">in</span> <span class="n">hydraulics</span><span class="p">:</span>
                    <span class="n">xf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_k_xtrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_k_xtrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>

                <span class="n">_</span><span class="p">,</span> <span class="n">xfmg</span><span class="p">,</span> <span class="n">zfmg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">),</span> <span class="n">xf_vec</span><span class="p">,</span>  <span class="n">zf_vec</span><span class="p">)</span>

                <span class="n">k_iso</span> <span class="o">*=</span> <span class="n">xfmg</span> <span class="o">*</span> <span class="n">zfmg</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Loop over assigned sequence architecutral elements</span>
                <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s1">&#39;r_k_ztrend&#39;</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]]:</span>
                        <span class="n">zfactor_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="s1">&#39;r_k_ztrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="s1">&#39;r_k_ztrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">)</span>  <span class="c1"># Z factor at each elevation</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">zfactor_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>

                    <span class="k">if</span> <span class="s1">&#39;r_k_xtrend&#39;</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]]:</span>
                        <span class="n">xfactor_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="s1">&#39;r_k_xtrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="s1">&#39;r_k_xtrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>  <span class="c1"># X factor at each x-coordiante</span>
                        <span class="n">xfactor_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span> <span class="o">*</span> <span class="n">xfactor_vec</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xfactor_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>

                    <span class="n">factor_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span> <span class="o">*</span> <span class="n">zfactor_arr</span> <span class="o">*</span> <span class="n">xfactor_arr</span>

                    <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">aei</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ae_lu</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">ei</span><span class="p">:</span>
                            <span class="n">k_iso</span><span class="p">[</span><span class="n">ae_arr</span> <span class="o">==</span> <span class="n">aei</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*=</span> <span class="n">factor_arr</span><span class="p">[</span><span class="n">ae_arr</span> <span class="o">==</span> <span class="n">aei</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Homogeneous case</span>
        <span class="k">for</span> <span class="n">hy_idx</span><span class="p">,</span> <span class="n">hyi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;l_hydro&#39;</span><span class="p">]):</span>
            <span class="n">hyi</span> <span class="o">=</span> <span class="n">hy_idx</span>
            <span class="n">k_iso</span><span class="p">[</span><span class="n">fac</span> <span class="o">==</span> <span class="n">hyi</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_k_h&#39;</span><span class="p">][</span><span class="n">hy_idx</span><span class="p">]</span>
            <span class="n">poros</span><span class="p">[</span><span class="n">fac</span> <span class="o">==</span> <span class="n">hyi</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_n&#39;</span><span class="p">][</span><span class="n">hy_idx</span><span class="p">]</span>
            <span class="n">anirat</span><span class="p">[</span><span class="n">fac</span> <span class="o">==</span> <span class="n">hyi</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;r_k_ratio&#39;</span><span class="p">][</span><span class="n">hy_idx</span><span class="p">]</span>

    <span class="sd">&quot;&quot;&quot; Assignment of anisotropy &quot;&quot;&quot;</span>
    <span class="c1"># Initialise storage arrays</span>
    <span class="n">ktensors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># convert angles to radians</span>
    <span class="n">azim</span> <span class="o">=</span> <span class="n">azim</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">dip</span> <span class="o">=</span> <span class="n">dip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>

    <span class="c1"># Create hydraulic conductivity tensors</span>
    <span class="n">kplane</span> <span class="o">=</span> <span class="n">anirat</span> <span class="o">**</span> <span class="mf">0.5</span>
    <span class="n">kperp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">anirat</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="c1"># T =========================</span>
    <span class="c1"># R = np.array([[np.cos(azim), np.sin(azim), 0],</span>
    <span class="c1">#                   [-np.sin(azim), np.cos(azim), 0],</span>
    <span class="c1">#                   [0, 0, 1]], dtype=np.float32) * \</span>
    <span class="c1">#         np.array([[np.cos(dip), 0, np.sin(dip)],</span>
    <span class="c1">#                   [0, 1, 0],</span>
    <span class="c1">#                   [-np.sin(dip), 0, np.cos(dip)]], dtype=np.float32)</span>
    <span class="c1"># /T =========================</span>

    <span class="c1"># Iterate over all nodes</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">k_iso</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;multi_index&#39;</span><span class="p">])</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">multi_index</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">multi_index</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">azim</span><span class="p">[</span><span class="n">ii</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">azim</span><span class="p">[</span><span class="n">ii</span><span class="p">]),</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">azim</span><span class="p">[</span><span class="n">ii</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">azim</span><span class="p">[</span><span class="n">ii</span><span class="p">]),</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dip</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dip</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">])],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dip</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dip</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">])]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">ktensors</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kplane</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">kplane</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">kperp</span><span class="p">[</span><span class="n">ii</span><span class="p">]]))</span> <span class="o">*</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span>

        <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>

    <span class="c1"># convert angles to radians</span>
    <span class="n">azim</span> <span class="o">=</span> <span class="n">azim</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">dip</span> <span class="o">=</span> <span class="n">dip</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">    Simulation outputs</span>
<span class="sd">    --------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;l_outputs&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;vtk&#39;</span><span class="p">:</span>
            <span class="n">outdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span>
                       <span class="s1">&#39;mat&#39;</span><span class="p">:</span> <span class="n">mat</span><span class="p">,</span>
                       <span class="s1">&#39;azim&#39;</span><span class="p">:</span> <span class="n">azim</span><span class="p">,</span>
                       <span class="s1">&#39;dip&#39;</span><span class="p">:</span> <span class="n">dip</span><span class="p">,</span>
                       <span class="s1">&#39;k_iso&#39;</span><span class="p">:</span> <span class="n">k_iso</span><span class="p">,</span>
                       <span class="s1">&#39;poros&#39;</span><span class="p">:</span> <span class="n">poros</span><span class="p">,</span>
                       <span class="s1">&#39;ae&#39;</span><span class="p">:</span> <span class="n">ae_arr</span><span class="p">,</span>
                       <span class="s1">&#39;seq&#39;</span><span class="p">:</span> <span class="n">seq_arr</span><span class="p">}</span>
            <span class="n">hu</span><span class="o">.</span><span class="n">to_vtr</span><span class="p">(</span><span class="n">outdict</span><span class="p">,</span> <span class="n">rundir</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;runname&#39;</span><span class="p">],</span> <span class="n">mg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;mat&#39;</span><span class="p">:</span>
            <span class="n">sio</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="n">rundir</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;runname&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.mat&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span>
                                                                 <span class="s1">&#39;azim&#39;</span><span class="p">:</span> <span class="n">azim</span><span class="p">,</span>
                                                                 <span class="s1">&#39;mat&#39;</span><span class="p">:</span> <span class="n">mat</span><span class="p">,</span>
                                                                 <span class="s1">&#39;dip&#39;</span><span class="p">:</span> <span class="n">dip</span><span class="p">,</span>
                                                                 <span class="s1">&#39;k_iso&#39;</span><span class="p">:</span> <span class="n">k_iso</span><span class="p">,</span>
                                                                 <span class="s1">&#39;ktensors&#39;</span><span class="p">:</span> <span class="n">ktensors</span><span class="p">,</span>
                                                                 <span class="s1">&#39;poros&#39;</span><span class="p">:</span> <span class="n">poros</span><span class="p">,</span>
                                                                 <span class="s1">&#39;seq&#39;</span><span class="p">:</span> <span class="n">seq_arr</span><span class="p">,</span>
                                                                 <span class="s1">&#39;ae&#39;</span><span class="p">:</span> <span class="n">ae_arr</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;npy&#39;</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">rundir</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;runname&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.npz&#39;</span><span class="p">,</span> <span class="n">props</span><span class="o">=</span><span class="n">props</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">hydraulics</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">props</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">k_iso</span><span class="p">,</span> <span class="n">ktensors</span><span class="p">,</span> <span class="n">poros</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">props</span><span class="p">,</span> <span class="n">params</span></div>

<span class="sd">&quot;&quot;&quot;-------------------------------------------------------------------------------------------------------------- &quot;&quot;&quot;</span>


<span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">Trough generators and utilities</span>
<span class="sd">--------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>


<div class="viewcode-block" id="gen_trough"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.gen_trough">[docs]</a><span class="k">def</span> <span class="nf">gen_trough</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">ae</span><span class="p">,</span> <span class="n">ae_arr</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ani</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create trough shapes.</span>

<span class="sd">    Args:</span>
<span class="sd">        tr      (dict):         trough parameters</span>
<span class="sd">        mg      (grid class):   model grid</span>
<span class="sd">        ae      (list):         architectural element unit details</span>
<span class="sd">        ae_arr  (ndarray):      3D array of sequeunce numbers</span>
<span class="sd">        count   (int):          material number</span>
<span class="sd">        ani     (bool):         Generate anisotropy?</span>

<span class="sd">    Returns:</span>
<span class="sd">        lpgrid: grid class of grid information</span>
<span class="sd">        lpdf:   leapfrog lithology as a pandas dataframe</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">z3</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">meshup</span><span class="p">()</span>    <span class="c1"># 3-D grid</span>

    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
        <span class="n">mat</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="n">azim</span><span class="p">,</span> <span class="n">dip</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">mat_count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">bg</span><span class="o">=</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_bg&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mat</span><span class="p">,</span> <span class="n">fac</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">mat_count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">bg</span><span class="o">=</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_bg&#39;</span><span class="p">],</span> <span class="n">ani</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">ae_arr_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Assign background values</span>
    <span class="n">ae_arr_i</span><span class="p">[</span><span class="n">ae_arr</span> <span class="o">==</span> <span class="n">ae</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ae</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># loop over trough top depths</span>
    <span class="k">if</span> <span class="s1">&#39;buffer&#39;</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">:</span>
        <span class="n">tr_bot</span> <span class="o">=</span> <span class="n">ae</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;buffer&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tr_bot</span> <span class="o">=</span> <span class="n">ae</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tr_top</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ae</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">tr_bot</span><span class="p">)</span> <span class="o">+</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;agg&#39;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">znow</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tr_bot</span><span class="p">,</span> <span class="n">tr_top</span><span class="p">,</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;agg&#39;</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">elno</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;el_z&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">mg</span><span class="o">.</span><span class="n">lx</span><span class="o">*</span><span class="n">mg</span><span class="o">.</span><span class="n">ly</span><span class="p">):</span>
            <span class="c1"># Reneration of trough parameters</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">rand_trough</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">mg</span><span class="o">=</span><span class="n">mg</span><span class="p">,</span> <span class="n">ztr</span><span class="o">=</span><span class="n">znow</span><span class="p">)</span>

            <span class="c1"># center of trough</span>
            <span class="k">if</span> <span class="s1">&#39;flag_display&#39;</span> <span class="ow">in</span> <span class="n">model</span> <span class="ow">and</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;flag_display&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Place troughs in domain centre for display features</span>
                <span class="n">xnow</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">ynow</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="s1">&#39;r_migrate&#39;</span> <span class="ow">in</span> <span class="n">tr</span> <span class="ow">and</span> <span class="n">znow</span> <span class="o">&gt;</span> <span class="n">tr_bot</span><span class="p">:</span>
                <span class="c1"># Migration of troughs</span>
                <span class="n">xnow</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_migrate&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_migrate&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ynow</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_migrate&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_migrate&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xnow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span><span class="p">)</span>
                <span class="n">ynow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">mg</span><span class="o">.</span><span class="n">ly</span><span class="o">/-</span><span class="mi">2</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_paleoflow&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_paleoflow&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>   <span class="c1"># orientation angle of trough (&#39;paleoflow&#39;)</span>
            <span class="n">angnow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_azimuth&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_azimuth&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>      <span class="c1"># orientation of material</span>

            <span class="c1"># Distances to ellipsoid centre</span>
            <span class="n">xd</span> <span class="o">=</span> <span class="n">x3</span> <span class="o">-</span> <span class="n">xnow</span>
            <span class="n">yd</span> <span class="o">=</span> <span class="n">y3</span> <span class="o">-</span> <span class="n">ynow</span>
            <span class="n">zd</span> <span class="o">=</span> <span class="n">z3</span> <span class="o">-</span> <span class="n">znow</span>

            <span class="c1"># Periodic boundary</span>
            <span class="k">if</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;flag_periodic&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">xd</span><span class="p">[</span><span class="n">xd</span> <span class="o">&gt;</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span>
                <span class="n">xd</span><span class="p">[</span><span class="n">xd</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">mg</span><span class="o">.</span><span class="n">lx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span>
                <span class="n">yd</span><span class="p">[</span><span class="n">yd</span> <span class="o">&gt;</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span>
                <span class="n">yd</span><span class="p">[</span><span class="n">yd</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">mg</span><span class="o">.</span><span class="n">ly</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span>
                <span class="n">zd</span><span class="p">[</span><span class="n">zd</span> <span class="o">&gt;</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span>
                <span class="n">zd</span><span class="p">[</span><span class="n">zd</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">mg</span><span class="o">.</span><span class="n">lz</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span>

            <span class="c1"># scaled and rotated distance squared</span>
            <span class="n">select</span><span class="p">,</span> <span class="n">R2</span> <span class="o">=</span> <span class="n">scale_rotate</span><span class="p">(</span><span class="n">xd</span><span class="p">,</span> <span class="n">yd</span><span class="p">,</span> <span class="n">zd</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">select</span><span class="p">,</span> <span class="n">ae_arr</span> <span class="o">&lt;=</span> <span class="n">ae</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>                <span class="c1"># Restrict selection to AE units equal or below current</span>


            <span class="sd">&quot;&quot;&quot;&quot; Assign internal structure &quot;&quot;&quot;</span>
            <span class="n">tr_struct</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;structure&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">tr_struct</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="n">tr_struct</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;bulb_l&#39;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">select</span><span class="p">)):</span>
                <span class="c1"># Skip section if no grid cells selected</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">select</span><span class="p">):</span>
                <span class="c1"># Skip section if no grid cells selected</span>
                <span class="k">pass</span>

            <span class="k">if</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;hetlev&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ae&#39;</span><span class="p">:</span>
                <span class="c1"># Add &#39;dip layers&#39; into trough</span>
                <span class="n">fac_now</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;l_facies&#39;</span><span class="p">])</span>
                <span class="n">fac</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">fac_now</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">azim</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">angnow</span>    <span class="c1"># Save angle</span>
                    <span class="n">dip</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_dip&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_dip&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>                    <span class="c1"># Assignment of architectural elements only</span>
            <span class="k">elif</span> <span class="n">tr_struct</span> <span class="o">==</span> <span class="s1">&#39;bulb&#39;</span><span class="p">:</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Add &#39;bulb&#39; layers into trough</span>
<span class="sd">                    - Dip is derived from the gradient of the truncated ellipsoid boundary</span>
<span class="sd">                    - Azimuth is the angle of the ellipsoid</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># Generate gradient information</span>
                <span class="n">dip_tr</span><span class="p">,</span> <span class="n">azim_tr</span> <span class="o">=</span> <span class="n">ellipsoid_gradient</span><span class="p">(</span><span class="n">xd</span><span class="p">,</span> <span class="n">yd</span><span class="p">,</span> <span class="n">zd</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">tr</span><span class="p">)</span>

                <span class="c1"># Assign generated values to grid cells</span>
                <span class="n">fac_now</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;l_facies&#39;</span><span class="p">])</span>
                <span class="n">fac</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">fac_now</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">dip</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">dip_tr</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
                    <span class="n">azim</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">azim_tr</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">tr_struct</span> <span class="o">==</span> <span class="s1">&#39;bulb_l&#39;</span><span class="p">:</span>

                <span class="c1"># Ellipsoid &#39;c&#39; radii</span>
                <span class="n">c_range</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;bulbset_d&#39;</span><span class="p">])</span>

                <span class="c1"># Iterate over internal truncated ellipsoids</span>
                <span class="k">for</span> <span class="n">c_idx</span><span class="p">,</span> <span class="n">c_now</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c_range</span><span class="p">):</span>
                    <span class="c1"># Get scale factor for ellipsoids -</span>
                    <span class="n">te_scale</span> <span class="o">=</span> <span class="n">c_now</span> <span class="o">/</span> <span class="n">c</span>
                    <span class="n">a_now</span><span class="p">,</span> <span class="n">b_now</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span> <span class="o">*</span> <span class="n">te_scale</span>

                    <span class="c1"># Internal scaled and rotated distance squared</span>
                    <span class="n">bulb_select</span><span class="p">,</span> <span class="n">bulb_R2</span> <span class="o">=</span> <span class="n">scale_rotate</span><span class="p">(</span><span class="n">xd</span><span class="p">,</span> <span class="n">yd</span><span class="p">,</span> <span class="n">zd</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">a_now</span><span class="p">,</span> <span class="n">b_now</span><span class="p">,</span> <span class="n">c_now</span><span class="p">)</span>

                    <span class="c1"># Generate gradient information</span>
                    <span class="n">dip_bulb</span><span class="p">,</span> <span class="n">azim_bulb</span> <span class="o">=</span> <span class="n">ellipsoid_gradient</span><span class="p">(</span><span class="n">xd</span><span class="p">,</span> <span class="n">yd</span><span class="p">,</span> <span class="n">zd</span><span class="p">,</span> <span class="n">a_now</span><span class="p">,</span> <span class="n">b_now</span><span class="p">,</span> <span class="n">c_now</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">bulb_select</span><span class="p">,</span> <span class="n">tr</span><span class="p">)</span>

                    <span class="c1"># Assign generated values to grid cells</span>
                    <span class="k">if</span> <span class="n">c_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Randomly choose facies</span>
                        <span class="n">fac_now</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;l_facies&#39;</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Choose next hydrofacies from alternating sets</span>
                        <span class="n">pf_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;l_facies&#39;</span><span class="p">])</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">fac_now</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span>    <span class="c1"># Get facies index</span>
                        <span class="n">fac_now</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;ll_altfacies&#39;</span><span class="p">][</span><span class="n">pf_i</span><span class="p">])</span>                   <span class="c1"># Get next alternating facies</span>

                    <span class="n">fac</span><span class="p">[</span><span class="n">bulb_select</span><span class="p">]</span> <span class="o">=</span> <span class="n">fac_now</span>                                      <span class="c1"># Alternating facies</span>
                    <span class="n">mat</span><span class="p">[</span><span class="n">bulb_select</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>

                    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                        <span class="n">dip</span><span class="p">[</span><span class="n">bulb_select</span><span class="p">]</span> <span class="o">=</span> <span class="n">dip_bulb</span><span class="p">[</span><span class="n">bulb_select</span><span class="p">]</span>
                        <span class="n">azim</span><span class="p">[</span><span class="n">bulb_select</span><span class="p">]</span> <span class="o">=</span> <span class="n">azim_bulb</span><span class="p">[</span><span class="n">bulb_select</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">tr_struct</span> <span class="o">==</span> <span class="s1">&#39;dip&#39;</span><span class="p">:</span>
                <span class="c1"># Add &#39;dip layers&#39; into trough, with alternating facies</span>
                <span class="n">do</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">av</span> <span class="o">=</span> <span class="n">dip_sets</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">znow</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="n">select</span><span class="p">,</span> <span class="n">azimuth_z</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>

                <span class="c1"># Assign generated values to grid cells</span>
                <span class="n">fac</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">fd</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">dip</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">dv</span>
                    <span class="n">azim</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">av</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Add &#39;dip layers&#39; into trough</span>
                <span class="n">fac</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;l_facies&#39;</span><span class="p">])</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">azim</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">angnow</span>    <span class="c1"># Save angle</span>
                    <span class="n">dip</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_dip&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_dip&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ae_arr_i</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">ae</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mat&#39;</span><span class="p">:</span> <span class="n">mat</span><span class="p">,</span> <span class="s1">&#39;azim&#39;</span><span class="p">:</span> <span class="n">azim</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">:</span> <span class="n">dip</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;ae_arr_i&#39;</span><span class="p">:</span> <span class="n">ae_arr_i</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mat&#39;</span><span class="p">:</span> <span class="n">mat</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;ae_arr_i&#39;</span><span class="p">:</span> <span class="n">ae_arr_i</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">props</span><span class="p">,</span> <span class="n">count</span></div>


<div class="viewcode-block" id="scale_rotate"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.scale_rotate">[docs]</a><span class="k">def</span> <span class="nf">scale_rotate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scale and rotate three-dimensional trough</span>

<span class="sd">    :Parameters:</span>
<span class="sd">        x, y, z: float</span>
<span class="sd">            spatial coordinates</span>
<span class="sd">        alpha: float</span>
<span class="sd">            rotation angle about the z-axis</span>
<span class="sd">        a, b, c: float</span>
<span class="sd">            axis lengths in x, y, z directions (ellipsoid length, width, depth)</span>
<span class="sd">    :return:</span>
<span class="sd">        select: grid cells within ellipsoid</span>
<span class="sd">        R2:     grid of scaled and rotated values</span>

<span class="sd">    : Authors:</span>
<span class="sd">        Jeremy Bennett</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">R2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
          <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">+</span>
          <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> \
         <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span>
          <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">+</span>
          <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> \
          <span class="n">z</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">c</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="c1">#  selection of cells</span>
    <span class="n">mask1</span> <span class="o">=</span> <span class="n">R2</span> <span class="o">&lt;=</span> <span class="mi">1</span>
    <span class="n">mask2</span> <span class="o">=</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="mi">0</span>
    <span class="n">select</span> <span class="o">=</span> <span class="n">mask1</span> <span class="o">&amp;</span> <span class="n">mask2</span>

    <span class="k">return</span> <span class="n">select</span><span class="p">,</span> <span class="n">R2</span></div>


<div class="viewcode-block" id="ellipsoid_gradient"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.ellipsoid_gradient">[docs]</a><span class="k">def</span> <span class="nf">ellipsoid_gradient</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">tr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate dip and strike values in rotated ellipsoids</span>

<span class="sd">    Args:</span>
<span class="sd">        x, y, z:    distances to centre of ellipsoid</span>
<span class="sd">        a, b, c:    majox/minor axes of ellipsoid</span>
<span class="sd">        alpha:      rotation of ellipsoid from mean flow direction</span>

<span class="sd">    Returns:</span>
<span class="sd">        dip:</span>
<span class="sd">        strike:</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">idx_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)))[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

    <span class="c1"># Calculate dip and strike for onion</span>
    <span class="n">dip_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">azimuth_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="n">select_z_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">select</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">idx_z</span><span class="p">])</span>                    <span class="c1"># Indices of grid cells in unit at top of unit</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">select_z_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">select_z_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">idx_z</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">select_z_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">select_z_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">idx_z</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">iz</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">ix</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">+</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">ix</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">+</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span>

    <span class="c1"># Get tangent plane coefficients</span>
    <span class="n">fx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> \
        <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">fy</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ix</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> \
        <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ix</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">fz</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iz</span> <span class="o">/</span> <span class="n">c</span>

    <span class="c1"># Normal vectors of tangent plane, horizontal plane, vertical plane</span>
    <span class="n">n_tan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">fz</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">n_horizontal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>

    <span class="c1"># Calculate the dip at each point</span>
    <span class="n">dip_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_dip&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">angle</span><span class="p">(</span><span class="n">n_tan</span><span class="p">,</span> <span class="n">n_horizontal</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>

    <span class="c1"># Insert into 2D array</span>
    <span class="n">dip2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">dip2d</span><span class="p">[</span><span class="n">select_z_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">select_z_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dip_vec</span>
    <span class="n">dip2d</span> <span class="o">=</span> <span class="n">dip2d</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="c1"># Apply to 3D arrays</span>
    <span class="n">dip_g</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">dip2d</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
    <span class="n">azimuth_g</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="k">return</span> <span class="n">dip_g</span><span class="p">,</span> <span class="n">azimuth_g</span></div>


<div class="viewcode-block" id="rand_trough"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.rand_trough">[docs]</a><span class="k">def</span> <span class="nf">rand_trough</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">mg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ztr</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly generate ellipsoid geometry parameters</span>

<span class="sd">    Args:</span>
<span class="sd">        tr:     ellipsoid parameters</span>
<span class="sd">        mg:     Meshgrid object</span>
<span class="sd">        ztr:    elevation of ellipsoid centre point</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ztr</span> <span class="ow">and</span> <span class="s1">&#39;r_geo_ztrend&#39;</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">:</span>
        <span class="n">zfactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">ztr</span><span class="p">,</span> <span class="p">[</span><span class="n">mg</span><span class="o">.</span><span class="n">oz</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">oz</span> <span class="o">+</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">],</span> <span class="p">[</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_geo_ztrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;r_geo_ztrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zfactor</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">zfactor</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">zfactor</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">zfactor</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span></div>

<span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">Channel generators and utilities</span>
<span class="sd">--------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>


<div class="viewcode-block" id="gen_channel"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.gen_channel">[docs]</a><span class="k">def</span> <span class="nf">gen_channel</span><span class="p">(</span><span class="n">ch_par</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">ae_array</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ani</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate channels architectural element:</span>
<span class="sd">        - Flow regime is assumed to be reasonably constant so the major geometry of the channels doesn&#39;t change so much</span>
<span class="sd">        - &#39;Migration&#39; of the channels according to a shift vector</span>

<span class="sd">    Args:</span>
<span class="sd">        ch_par:         channel parameters</span>
<span class="sd">        mg:         model grid class</span>
<span class="sd">        z_in:       starting depth</span>
<span class="sd">        thickness:  thickness of architectural element</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Vectors of spatial coordinates</span>
    <span class="n">xvec</span><span class="p">,</span> <span class="n">yvec</span><span class="p">,</span> <span class="n">zvec</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span>
    <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span> <span class="n">yvec</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>          <span class="c1"># 2-D grid</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">z3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>          <span class="c1"># 2-D grid</span>

    <span class="c1"># Initialize storage arrays</span>
    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
         <span class="n">mat</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="n">azim</span><span class="p">,</span> <span class="n">dip</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">bg</span><span class="o">=</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_bg&#39;</span><span class="p">],</span> <span class="n">mat_count</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mat</span><span class="p">,</span> <span class="n">fac</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">bg</span><span class="o">=</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_bg&#39;</span><span class="p">],</span> <span class="n">mat_count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">ani</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">ae_arr_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ae_array</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">ae_arr_i</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># start location</span>
    <span class="n">total_channels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;channel_no&#39;</span><span class="p">])</span>
    <span class="n">xstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_channels</span><span class="p">)</span>
    <span class="n">ystart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">yvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">yvec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">total_channels</span><span class="p">)</span>

    <span class="c1"># loop over channel top depths</span>
    <span class="k">if</span> <span class="s1">&#39;buffer&#39;</span> <span class="ow">in</span> <span class="n">ch_par</span><span class="p">:</span>
        <span class="n">ch_bot</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;buffer&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ch_bot</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ch_top</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_mig&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">znow</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ch_bot</span><span class="p">,</span> <span class="n">ch_top</span><span class="p">,</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_mig&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39; z = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">znow</span><span class="p">))</span>
        <span class="c1"># Assign linear trend to channel sizes</span>
        <span class="k">if</span> <span class="s1">&#39;r_geo_ztrend&#39;</span> <span class="ow">in</span> <span class="n">ch_par</span><span class="p">:</span>
            <span class="n">zfactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">znow</span><span class="p">,</span> <span class="p">[</span><span class="n">mg</span><span class="o">.</span><span class="n">oz</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">oz</span> <span class="o">+</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">],</span> <span class="p">[</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_geo_ztrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_geo_ztrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zfactor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">z_ch_width</span> <span class="o">=</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">zfactor</span>
        <span class="n">z_ch_depth</span> <span class="o">=</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">zfactor</span>

        <span class="c1"># Loop over total channels per sequence</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_channels</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Loop over multiple channels at &#39;timestep&#39; &quot;&quot;&quot;</span>
            <span class="n">aha</span> <span class="o">=</span> <span class="n">ferguson_channel</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">],</span>  <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;ds&#39;</span><span class="p">],</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;eps_factor&#39;</span><span class="p">])</span>

            <span class="sd">&quot;&quot;&quot; Get flow direction in channel for azimuth &quot;&quot;&quot;</span>
            <span class="c1"># For periodicity shift trajectories into model unit cell</span>
            <span class="k">if</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;flag_periodic&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">aha</span><span class="p">[</span><span class="n">aha</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">yvec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span>
                <span class="n">aha</span><span class="p">[</span><span class="n">aha</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">yvec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span>

            <span class="c1"># initialize 2-D distance matrix</span>
            <span class="n">D</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>

            <span class="c1"># initialize sum of inverse-distance weights</span>
            <span class="n">sumW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># initialize velocity orientation at this level</span>
            <span class="n">vx_znow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">vy_znow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># loop over all points of trajectory</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aha</span><span class="p">)):</span>
                <span class="c1"># distance to current point</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x2</span> <span class="o">-</span> <span class="n">aha</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">aha</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

                <span class="c1"># smallest distance of entire grid to all points so far</span>
                <span class="n">D</span><span class="p">[</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">]</span>

                <span class="c1"># inverse-distance weight for velocity interpolation</span>
                <span class="n">W</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">20</span>
                <span class="n">W</span><span class="p">[</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">z_ch_width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">z_ch_width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>

                <span class="c1"># velocity interpolation in 2-D</span>
                <span class="n">vx_znow</span> <span class="o">+=</span> <span class="n">aha</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">W</span>
                <span class="n">vy_znow</span> <span class="o">+=</span> <span class="n">aha</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">W</span>
                <span class="n">sumW</span> <span class="o">+=</span> <span class="n">W</span>

            <span class="n">vx_znow</span> <span class="o">/=</span> <span class="n">sumW</span>
            <span class="n">vy_znow</span> <span class="o">/=</span> <span class="n">sumW</span>

            <span class="c1"># Assign facies sets with dip values</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_dip&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">do</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">av</span> <span class="o">=</span> <span class="n">dip_sets</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">ch_par</span><span class="p">,</span> <span class="n">znow</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="p">[</span><span class="n">aha</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">aha</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vx_znow</span><span class="p">,</span> <span class="n">vy_znow</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">do</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span> <span class="o">+</span> <span class="n">count</span>
                <span class="n">fd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;l_facies&#39;</span><span class="p">]))</span>
                <span class="n">dv</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">av</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>

            <span class="sd">&quot;&quot;&quot; Copy results into 3-D field &quot;&quot;&quot;</span>
            <span class="c1"># Iterate over all nodes below current top elevation</span>
            <span class="n">d_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">znow</span> <span class="o">-</span> <span class="n">z_ch_depth</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">znow</span><span class="p">)))</span>      <span class="c1"># Depth range</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>        <span class="c1"># Only compute if channel depth range is finite</span>

                <span class="c1"># Get mask arrays for each condition</span>
                <span class="n">in_channel</span> <span class="o">=</span> <span class="n">D</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">z_ch_width</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">-</span> <span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">znow</span><span class="p">)</span> <span class="o">-</span> <span class="n">z3</span><span class="p">)</span> <span class="o">*</span> <span class="n">mg</span><span class="o">.</span><span class="n">dz</span> <span class="o">*</span> <span class="n">z_ch_width</span> <span class="o">/</span> <span class="p">(</span><span class="n">z_ch_depth</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>     <span class="c1"># is grid cell in channel</span>
                <span class="n">finite_v</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vx_znow</span><span class="p">)</span>            <span class="c1"># Only assign if velocity is finite</span>
                <span class="n">below_top</span> <span class="o">=</span> <span class="n">ae_array</span> <span class="o">&lt;=</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>            <span class="c1"># Don&#39;t assign values to locations higher than top contact surface</span>
                <span class="n">chan_mask</span> <span class="o">=</span> <span class="n">in_channel</span> <span class="o">*</span> <span class="n">finite_v</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">below_top</span>

                <span class="c1"># Assign properties</span>
                <span class="n">fac</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fd</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">ae_arr_i</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="s1">&#39;l_lag&#39;</span> <span class="ow">in</span> <span class="n">ch_par</span><span class="p">:</span>
                    <span class="n">in_lag</span> <span class="o">=</span> <span class="p">(</span><span class="n">znow</span> <span class="o">-</span> <span class="n">z_ch_depth</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;l_lag&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="n">z3</span> <span class="o">*</span> <span class="n">mg</span><span class="o">.</span><span class="n">dz</span>   <span class="c1"># Is grid cell in channel</span>
                    <span class="n">fac</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">in_channel</span><span class="p">,</span> <span class="n">in_lag</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;l_lag&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="c1"># calcuate azimuth, to 1 degree</span>
                    <span class="n">azim2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vx_znow</span><span class="p">,</span> <span class="n">vy_znow</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="n">azim3d</span> <span class="o">=</span> <span class="n">azim2d</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>
                    <span class="n">azim</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">azim3d</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span>
                    <span class="n">dip</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">dv</span>

                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Shift starting values with migration vector from parameter file</span>
        <span class="n">xstart</span> <span class="o">+=</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_mig&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ystart</span> <span class="o">+=</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_mig&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mat&#39;</span><span class="p">:</span> <span class="n">mat</span><span class="p">,</span> <span class="s1">&#39;azim&#39;</span><span class="p">:</span> <span class="n">azim</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">:</span> <span class="n">dip</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;ae_arr_i&#39;</span><span class="p">:</span> <span class="n">ae_arr_i</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mat&#39;</span><span class="p">:</span> <span class="n">mat</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;ae_arr_i&#39;</span><span class="p">:</span> <span class="n">ae_arr_i</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">props</span><span class="p">,</span> <span class="n">count</span></div>


<div class="viewcode-block" id="ferguson_channel"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.ferguson_channel">[docs]</a><span class="k">def</span> <span class="nf">ferguson_channel</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">eps_factor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate channel centrelines using the Ferguson (1976) disturbed meander model</span>
<span class="sd">    Implementation of AR2 autoregressive model</span>
<span class="sd">    http://onlinelibrary.wiley.com/doi/10.1002/esp.3290010403/full</span>

<span class="sd">    :param mg:</span>
<span class="sd">    :param h:</span>
<span class="sd">    :param k:</span>
<span class="sd">    :param eps_factor:</span>
<span class="sd">    :return:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Parameters</span>
    <span class="n">ds</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">10</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span>

    <span class="c1"># Centreline starting point</span>
    <span class="n">xp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">yp</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Calculate channel directions</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">ferguson_theta</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">eps_factor</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

    <span class="c1"># Interpolate channel direction over interval of interest</span>
    <span class="n">s_interp</span><span class="p">,</span> <span class="n">th_interp</span> <span class="o">=</span> <span class="n">curve_interp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>

    <span class="c1"># Storage array</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">th_interp</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">th_idx</span><span class="p">,</span> <span class="n">th_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">th_interp</span><span class="p">):</span>
        <span class="n">vx</span> <span class="o">=</span> <span class="n">ds</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">th_i</span><span class="p">)</span>
        <span class="n">vy</span> <span class="o">=</span> <span class="n">ds</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">th_i</span><span class="p">)</span>
        <span class="n">xp</span> <span class="o">+=</span> <span class="n">vx</span>
        <span class="n">yp</span> <span class="o">+=</span> <span class="n">vy</span>

        <span class="c1"># Assign to storage array</span>
        <span class="n">outputs</span><span class="p">[</span><span class="n">th_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xp</span>       <span class="c1"># x coordinate</span>
        <span class="n">outputs</span><span class="p">[</span><span class="n">th_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yp</span>       <span class="c1"># y coordinate</span>
        <span class="n">outputs</span><span class="p">[</span><span class="n">th_idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vx</span>       <span class="c1"># vx</span>
        <span class="n">outputs</span><span class="p">[</span><span class="n">th_idx</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">vy</span>       <span class="c1"># vY</span>

    <span class="c1"># Rotate meanders into mean flow direction</span>
    <span class="n">mean_th</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">th_interp</span><span class="p">)</span>
    <span class="n">rotMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">mean_th</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">mean_th</span><span class="p">)],</span>
                          <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">mean_th</span><span class="p">),</span>  <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">mean_th</span><span class="p">)]])</span>
    <span class="n">roro</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotMatrix</span><span class="p">,</span> <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

    <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotMatrix</span><span class="p">,</span> <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="c1"># Move to random starting location</span>
    <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">roro</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">roro</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">mg</span><span class="o">.</span><span class="n">ly</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Remove values before model domain</span>
    <span class="n">indomain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">outputs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">mg</span><span class="o">.</span><span class="n">ox</span><span class="p">,</span> <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="n">indomain</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">outputs</span></div>


<div class="viewcode-block" id="ferguson_theta"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.ferguson_theta">[docs]</a><span class="k">def</span> <span class="nf">ferguson_theta</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">eps_factor</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate channel direction angle</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Storage arrays</span>
    <span class="n">th_store</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">idex</span><span class="p">,</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">idex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">idex</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">th_store</span><span class="p">[</span><span class="n">idex</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span><span class="o">*</span><span class="n">eps_factor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">th_store</span><span class="p">[</span><span class="n">idex</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">th_store</span><span class="p">[</span><span class="n">idex</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">eps_factor</span>

        <span class="n">th_store</span><span class="p">[</span><span class="n">idex</span><span class="p">]</span> <span class="o">=</span> <span class="n">thetaAR2</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">th_store</span></div>


<div class="viewcode-block" id="thetaAR2"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.thetaAR2">[docs]</a><span class="k">def</span> <span class="nf">thetaAR2</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of AR2 autoregressive model (Ferguson, 1976, Eq.15)</span>
<span class="sd">    http://onlinelibrary.wiley.com/doi/10.1002/esp.3290010403/full</span>

<span class="sd">    t1: theta(i-1)</span>
<span class="sd">    t2: theta(i-2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="n">h</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eps</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">t1</span> <span class="o">+</span> <span class="n">b2</span><span class="o">*</span><span class="n">t2</span></div>


<span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">Sheet generators and utilities</span>
<span class="sd">--------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>


<div class="viewcode-block" id="gen_sheet"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.gen_sheet">[docs]</a><span class="k">def</span> <span class="nf">gen_sheet</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">ae_array</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ani</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate gravel sheet with internal heterogeneity</span>
<span class="sd">    Args:</span>
<span class="sd">        sh:         sheet parameters</span>
<span class="sd">        mg:         model grid class</span>
<span class="sd">        seq:        sequence parameters [sequence number, z_bottom, z_top, architectural element, geometry]</span>
<span class="sd">        ae_array:  sequence array</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize storage arrays</span>
    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
         <span class="n">mat</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="n">azim</span><span class="p">,</span> <span class="n">dip</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mat</span><span class="p">,</span> <span class="n">fac</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">ani</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Massive bedding -----------------------------------</span>
    <span class="k">if</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;lens_thickness&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Generate dip</span>
        <span class="k">if</span> <span class="s1">&#39;r_dip&#39;</span> <span class="ow">in</span> <span class="n">sh</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;r_dip&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">do</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">av</span> <span class="o">=</span> <span class="n">dip_sets</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">sh</span><span class="p">,</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>               <span class="c1"># Generate facies sets</span>
            <span class="n">fac</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">fd</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">mat</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">do</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">count</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">do</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                <span class="n">azim</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">dip</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dv</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mat</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">count</span>
            <span class="n">fac</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;l_facies&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                <span class="n">azim</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">dip</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Create lenses over depths ------------------------------</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Assign lens thickness for sequence</span>
        <span class="k">if</span> <span class="s1">&#39;r_geo_ztrend&#39;</span> <span class="ow">in</span> <span class="n">sh</span><span class="p">:</span>
            <span class="n">zfactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]),</span> <span class="p">[</span><span class="n">mg</span><span class="o">.</span><span class="n">oz</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">oz</span> <span class="o">+</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">],</span> <span class="p">[</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;r_geo_ztrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;r_geo_ztrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">z_lens_thick</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;lens_thickness&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">zfactor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z_lens_thick</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;lens_thickness&#39;</span><span class="p">]</span>
        <span class="n">z_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">z_lens_thick</span><span class="p">)</span>

        <span class="c1"># Loop over lenses</span>
        <span class="k">for</span> <span class="n">znow</span> <span class="ow">in</span> <span class="n">z_lens</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">z_bottom</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">znow</span><span class="p">)</span>
            <span class="n">z_top</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">znow</span> <span class="o">+</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;lens_thickness&#39;</span><span class="p">]),</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">)</span>
            <span class="n">z_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">z_bottom</span><span class="p">,</span> <span class="n">z_top</span><span class="p">)</span>

            <span class="c1"># Generate dip</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;r_dip&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">do</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">av</span> <span class="o">=</span> <span class="n">dip_sets</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">sh</span><span class="p">,</span> <span class="n">znow</span><span class="p">)</span>               <span class="c1"># Generate facies sets</span>

                <span class="c1"># Iterate over all nodes - Brute force approach :(</span>
                <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">ae_array</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;multi_index&#39;</span><span class="p">])</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">z_range</span> <span class="ow">and</span> <span class="n">ae_array</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">fac</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">fd</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span>
                        <span class="n">mat</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">do</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span>

                    <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>

                <span class="n">count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">do</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">azim</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">z_range</span><span class="p">]</span> <span class="o">=</span> <span class="n">av</span>
                    <span class="n">dip</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">z_range</span><span class="p">]</span> <span class="o">=</span> <span class="n">dv</span>   <span class="c1"># Assign facies sets to storage arrays</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fac</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">z_range</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;l_facies&#39;</span><span class="p">])</span>
                <span class="n">mat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">z_range</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">azim</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">z_range</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">dip</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">z_range</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mat&#39;</span><span class="p">:</span> <span class="n">mat</span><span class="p">,</span> <span class="s1">&#39;azim&#39;</span><span class="p">:</span> <span class="n">azim</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">:</span> <span class="n">dip</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mat&#39;</span><span class="p">:</span> <span class="n">mat</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">props</span><span class="p">,</span> <span class="n">count</span></div>


<div class="viewcode-block" id="dip_sets"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.dip_sets">[docs]</a><span class="k">def</span> <span class="nf">dip_sets</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">aep</span><span class="p">,</span> <span class="n">znow</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="p">[],</span> <span class="n">select</span><span class="o">=</span><span class="p">[],</span> <span class="n">azimuth_z</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate dip angles and assign to the dip matrix</span>

<span class="sd">    Args:</span>
<span class="sd">        mg:         Mesh grid object class</span>
<span class="sd">        aep:        Architectural element parameters (dict)</span>
<span class="sd">        channel:    Tuple of x,y coordinates of channel (omitted for linear flows)</span>
<span class="sd">                        - x, y coordinates of channel</span>
<span class="sd">                        - vx, vy of channel flow</span>
<span class="sd">        select:     Model grid nodes to assign</span>

<span class="sd">    Returns:</span>
<span class="sd">        dip_out:    Array of assigned dip values</span>
<span class="sd">        fac_out:    Array of assigned hydrofacies</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Vectors of spatial coordinates of grid</span>
    <span class="c1"># xgvec, ygvec, zgvec = mg.vec()                              # Grid vectors</span>
    <span class="n">xtemp</span><span class="p">,</span> <span class="n">ytemp</span><span class="p">,</span> <span class="n">ztemp</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">meshup</span><span class="p">()</span>      <span class="c1"># 3-D grid</span>

    <span class="c1"># Define series of points for plane equations</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Interpolate points along the channel trajectory</span>
        <span class="n">x_dip</span><span class="p">,</span> <span class="n">y_dip</span> <span class="o">=</span> <span class="n">curve_interp</span><span class="p">(</span><span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">channel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">aep</span><span class="p">[</span><span class="s1">&#39;dipset_d&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;r_azimuth&#39;</span> <span class="ow">in</span> <span class="n">aep</span><span class="p">:</span>
            <span class="n">azimuth_z</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;r_azimuth&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">aep</span><span class="p">[</span><span class="s1">&#39;r_azimuth&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">xst</span> <span class="o">=</span> <span class="o">-</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;dipset_d&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">20</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">aep</span><span class="p">[</span><span class="s1">&#39;dipset_d&#39;</span><span class="p">])</span>        <span class="c1"># Starting x-coordinate of plane points</span>
        <span class="n">xend</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span> <span class="o">*</span> <span class="mf">1.5</span> <span class="o">+</span> <span class="n">xst</span>                                                  <span class="c1"># Final x-coordinate of plane points</span>

        <span class="c1"># Get coordinate differences</span>
        <span class="n">lamb_dip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xst</span><span class="p">,</span> <span class="n">xend</span><span class="p">,</span> <span class="n">aep</span><span class="p">[</span><span class="s1">&#39;dipset_d&#39;</span><span class="p">])</span>
        <span class="n">xpvec</span> <span class="o">=</span> <span class="n">lamb_dip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">azimuth_z</span><span class="p">))</span>
        <span class="n">ypvec</span> <span class="o">=</span> <span class="n">lamb_dip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">azimuth_z</span><span class="p">))</span>

        <span class="c1"># Calculate coordinates of dip points</span>
        <span class="n">x_dip</span> <span class="o">=</span> <span class="n">xst</span> <span class="o">+</span> <span class="n">xpvec</span>
        <span class="n">y_dip</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">ypvec</span>

    <span class="c1"># Calculate normal vector components in x/y by getting the difference between points</span>

    <span class="n">p_setlamb</span> <span class="o">=</span> <span class="p">(</span><span class="n">xpvec</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ypvec</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="c1"># Define normal vector (This might change if the plane is angled (i.e. channel settings)</span>
    <span class="n">dip_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;r_dip&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">aep</span><span class="p">[</span><span class="s1">&#39;r_dip&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">dip_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xpvec</span><span class="p">))</span> <span class="o">*</span> <span class="n">dip_z</span>
    <span class="n">dip_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xpvec</span><span class="p">,</span> <span class="n">ypvec</span><span class="p">,</span> <span class="n">p_setlamb</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">90</span><span class="o">-</span><span class="n">dip_set</span><span class="p">))])</span> <span class="c1">#np.array((1, 0, np.tan(np.deg2rad(90 - aep[&#39;r_dip&#39;][1]))))</span>

    <span class="n">set_no</span> <span class="o">=</span> <span class="n">planepoint</span><span class="p">(</span><span class="n">dip_norm</span><span class="p">,</span> <span class="n">x_dip</span><span class="p">,</span> <span class="n">y_dip</span><span class="p">,</span> <span class="n">znow</span><span class="p">,</span> <span class="n">xtemp</span><span class="p">,</span> <span class="n">ytemp</span><span class="p">,</span> <span class="n">ztemp</span><span class="p">,</span> <span class="n">select</span><span class="p">)</span>
    <span class="c1"># Re-index set_no, starting from 1 to work with &#39;count&#39;</span>
    <span class="n">set_no</span> <span class="o">=</span> <span class="n">reindex</span><span class="p">(</span><span class="n">set_no</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="sd">&quot;&quot;&quot; Assign hydrofacies &quot;&quot;&quot;</span>
    <span class="c1"># Initialise hydrofacies array</span>
    <span class="n">fac_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;ll_altfacies&#39;</span> <span class="ow">in</span> <span class="n">aep</span><span class="p">:</span>
        <span class="c1"># Alternating hydrofacies</span>
        <span class="n">ae_fac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;l_facies&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">fac_now</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ae_fac</span><span class="p">)</span>       <span class="c1"># Initialise previous facies</span>
        <span class="k">for</span> <span class="n">idi</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">set_no</span><span class="p">):</span>
            <span class="n">pf_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">fac_now</span> <span class="o">==</span> <span class="n">ae_fac</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>                                         <span class="c1"># Get previous facies index</span>
            <span class="n">fac_now</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;ll_altfacies&#39;</span><span class="p">][</span><span class="n">pf_i</span><span class="p">])</span>  <span class="c1"># Get next alternating facies</span>
            <span class="n">fac_set</span><span class="p">[</span><span class="n">set_no</span> <span class="o">==</span> <span class="n">idi</span><span class="p">]</span> <span class="o">=</span> <span class="n">fac_now</span>                                                    <span class="c1"># Set previous facies</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">facies</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;l_facies&#39;</span><span class="p">]):</span>      <span class="c1"># Cycle over hydrofacies in element</span>
            <span class="n">fac_set</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">set_no</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">facies</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Random assignment of hydrofacies</span>
        <span class="k">for</span> <span class="n">idi</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">set_no</span><span class="p">):</span>
            <span class="n">fac_set</span><span class="p">[</span><span class="n">set_no</span> <span class="o">==</span> <span class="n">idi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;l_facies&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">set_no</span><span class="p">,</span> <span class="n">fac_set</span><span class="p">,</span> <span class="n">dip_z</span><span class="p">,</span> <span class="n">azimuth_z</span></div>


<div class="viewcode-block" id="curve_interp"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.curve_interp">[docs]</a><span class="k">def</span> <span class="nf">curve_interp</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">spacing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate evenly spaced points along a curve. This code is based on code in an answer posted by &#39;Unutbu&#39; on</span>
<span class="sd">    http://stackoverflow.com/questions/19117660/how-to-generate-equispaced-interpolating-values (retrieved 17/04/2017)</span>

<span class="sd">    Args:</span>
<span class="sd">        xc:</span>
<span class="sd">        yc:</span>
<span class="sd">        spacing:</span>

<span class="sd">    Returns:</span>
<span class="sd">        xn:</span>
<span class="sd">        yn:</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">xc</span><span class="p">),</span> <span class="n">spacing</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="n">xc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xc</span><span class="p">)),</span> <span class="n">xc</span><span class="p">)</span>
    <span class="n">yc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">yc</span><span class="p">)),</span> <span class="n">yc</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="n">spacing</span>
    <span class="n">ic</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">ic</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">xc</span><span class="p">):</span>
        <span class="n">total_dist</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ic</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xc</span><span class="p">)):</span>
            <span class="n">total_dist</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">xc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">xc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">yc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">yc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">total_dist</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">xn</span> <span class="o">=</span> <span class="n">xc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">yn</span> <span class="o">=</span> <span class="n">yc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="c1"># fig, ax = plt.subplots()</span>
    <span class="c1"># ax.plot(xc, yc, &#39;-&#39;)</span>
    <span class="c1"># ax.scatter(xn, yn)</span>
    <span class="c1"># ax.set_aspect(&#39;equal&#39;)</span>
    <span class="c1"># plt.show()</span>

    <span class="k">return</span> <span class="n">xn</span><span class="p">,</span> <span class="n">yn</span></div>


<div class="viewcode-block" id="dip_rotate"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.dip_rotate">[docs]</a><span class="k">def</span> <span class="nf">dip_rotate</span><span class="p">(</span><span class="n">azimuth_in</span><span class="p">,</span> <span class="n">dip_in</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate dip angle based on azimuth</span>
<span class="sd">    Note that inputs and outputs are in degrees</span>

<span class="sd">    Args:</span>
<span class="sd">        azimuth_in:</span>
<span class="sd">        dip_in:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">azimuth_in</span> <span class="o">=</span> <span class="n">azimuth_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
    <span class="n">dip_in</span> <span class="o">=</span> <span class="n">dip_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
    <span class="n">dip_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">azimuth_in</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">azimuth_in</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">dip_in</span><span class="p">))</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">azimuth_in</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">azimuth_in</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">dip_in</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">dip_out</span></div>

<span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">Internal heteogeneity utilities</span>
<span class="sd">--------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>


<div class="viewcode-block" id="specsim"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.specsim">[docs]</a><span class="k">def</span> <span class="nf">specsim</span><span class="p">(</span><span class="n">gr</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">corl</span><span class="p">,</span> <span class="n">twod</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate random variables stationary covariance function using spectral techniques of Dietrich &amp; Newsam (1993)</span>

<span class="sd">    Args:</span>
<span class="sd">        gr:     Grid class object</span>
<span class="sd">        var:    variance</span>
<span class="sd">        corl:   Tuple of correlation length of random variable</span>
<span class="sd">        twod:   Flag for two-dimensional simulation</span>

<span class="sd">    Returns:</span>
<span class="sd">        bigy:   Random gaussian variable</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">twod</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">yy</span><span class="p">,</span> <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">gr</span><span class="o">.</span><span class="n">ny</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">gr</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="n">gr</span><span class="o">.</span><span class="n">ny</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">gr</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="n">gr</span><span class="o">.</span><span class="n">dy</span><span class="p">),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">gr</span><span class="o">.</span><span class="n">nx</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">gr</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">gr</span><span class="o">.</span><span class="n">nx</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">gr</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">gr</span><span class="o">.</span><span class="n">dx</span><span class="p">))</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">((</span><span class="n">xx</span> <span class="o">/</span> <span class="n">corl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">yy</span> <span class="o">/</span> <span class="n">corl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>      <span class="c1"># Compute distance from origin</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">zz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">gr</span><span class="o">.</span><span class="n">ny</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">gr</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="n">gr</span><span class="o">.</span><span class="n">ny</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">gr</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="n">gr</span><span class="o">.</span><span class="n">dy</span><span class="p">),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">gr</span><span class="o">.</span><span class="n">nx</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">gr</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">gr</span><span class="o">.</span><span class="n">nx</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">gr</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">gr</span><span class="o">.</span><span class="n">dx</span><span class="p">),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">gr</span><span class="o">.</span><span class="n">nz</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">gr</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="n">gr</span><span class="o">.</span><span class="n">nz</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">gr</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="n">gr</span><span class="o">.</span><span class="n">dz</span><span class="p">))</span>

        <span class="c1"># Compute distance from origin</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">((</span><span class="n">xx</span> <span class="o">/</span> <span class="n">corl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">yy</span> <span class="o">/</span> <span class="n">corl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">zz</span> <span class="o">/</span> <span class="n">corl</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="n">ntot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>

    <span class="c1"># Covariance matrix of variables</span>
    <span class="c1">#ryy = np.exp(-h**2) * var          # Gaussian</span>
    <span class="n">ryy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="o">*</span> <span class="n">var</span>      <span class="c1"># Exponential</span>

    <span class="c1"># Power spectrum of variable</span>
    <span class="n">syy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">ryy</span><span class="p">))</span> <span class="o">/</span> <span class="n">ntot</span>
    <span class="n">syy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">syy</span><span class="p">)</span>       <span class="c1"># Remove imaginary artifacts</span>
    <span class="k">if</span> <span class="n">twod</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">syy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">syy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">real</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">syy</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">imag</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">syy</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">real</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">imag</span>
    <span class="n">rand</span> <span class="o">=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="p">(</span><span class="n">syy</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">bigy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">rand</span> <span class="o">*</span> <span class="n">ntot</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">bigy</span></div>


<span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">Assignment of hydraulic properties</span>
<span class="sd">--------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">General functions</span>
<span class="sd">--------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>


<div class="viewcode-block" id="save_arrays"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.save_arrays">[docs]</a><span class="k">def</span> <span class="nf">save_arrays</span><span class="p">(</span><span class="n">arr_size</span><span class="p">,</span> <span class="n">bg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mat_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ani</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate arrays for material properties storage</span>

<span class="sd">    Args:</span>
<span class="sd">        arr_size:       Size of array</span>
<span class="sd">        bg:             List of background values for each array</span>
<span class="sd">        ani:            Boolean if anisotropy is to be generated</span>
<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">bg</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>

    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">arr_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">*</span> <span class="n">mat_count</span>             <span class="c1"># initialize material</span>
    <span class="n">fac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">arr_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">bg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>              <span class="c1"># initialize hydrofacies</span>

    <span class="k">if</span> <span class="n">ani</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">azim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">arr_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="n">bg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>     <span class="c1"># initialize azimuth angle</span>
        <span class="n">dip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">arr_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="n">bg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>       <span class="c1"># initialize dip angle</span>
        <span class="k">return</span> <span class="n">mat</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="n">azim</span><span class="p">,</span> <span class="n">dip</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mat</span><span class="p">,</span> <span class="n">fac</span></div>


<div class="viewcode-block" id="prob_choose"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.prob_choose">[docs]</a><span class="k">def</span> <span class="nf">prob_choose</span><span class="p">(</span><span class="n">choices</span><span class="p">,</span> <span class="n">probs</span><span class="p">):</span>
    <span class="n">ae_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">chi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">choices</span><span class="p">)):</span>
        <span class="n">ae_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">choices</span><span class="p">[</span><span class="n">chi</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="n">chi</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">choice</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ae_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">choice</span></div>


<div class="viewcode-block" id="angle"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.angle">[docs]</a><span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return angle between two vectors in [°] &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))))</span></div>


<div class="viewcode-block" id="reindex"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.reindex">[docs]</a><span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="n">inray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Reindex array from 0 &quot;&quot;&quot;</span>
    <span class="n">remat</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">inray</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">inray</span><span class="p">)))))</span>      <span class="c1"># Dict of old &amp; new indices</span>
    <span class="n">vecmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">remat</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vecmat</span><span class="p">(</span><span class="n">inray</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="channel_checker"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.channel_checker">[docs]</a><span class="k">def</span> <span class="nf">channel_checker</span><span class="p">(</span><span class="n">param_file</span><span class="p">,</span> <span class="n">ae_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    channel_checker function for quickly assessing the shape of channel inputs</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">run</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">sequences</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">,</span> <span class="n">flowtrans</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">mg</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">model_setup</span><span class="p">(</span><span class="n">param_file</span><span class="p">)</span>
    <span class="n">ch_par</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">ae_name</span><span class="p">]</span>

    <span class="n">xstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ystart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">model</span><span class="p">[</span><span class="s1">&#39;ly&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;ly&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>

    <span class="n">tx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_t&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_t&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">tx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_t2&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_t2&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_amp&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;r_amp&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># starting angle in degree</span>
    <span class="n">angstart</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
    <span class="n">vabs</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">chs</span> <span class="o">=</span> <span class="n">channel_solve</span><span class="p">(</span><span class="n">xstart</span><span class="p">,</span> <span class="n">ystart</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">tx2</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">angstart</span><span class="p">,</span> <span class="n">vabs</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">chs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">chs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="s1">&#39;datalim&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="planepoint"><a class="viewcode-back" href="../../hyvr.html#hyvr.hyvr.planepoint">[docs]</a><span class="k">def</span> <span class="nf">planepoint</span><span class="p">(</span><span class="n">dip_norm</span><span class="p">,</span> <span class="n">x_dip</span><span class="p">,</span> <span class="n">y_dip</span><span class="p">,</span> <span class="n">znow</span><span class="p">,</span> <span class="n">xtemp</span><span class="p">,</span> <span class="n">ytemp</span><span class="p">,</span> <span class="n">ztemp</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        dip_norm:</span>
<span class="sd">        x_dip:</span>
<span class="sd">        y_dip:</span>
<span class="sd">        znow:</span>
<span class="sd">        xtemp:</span>
<span class="sd">        ytemp:</span>
<span class="sd">        ztemp:</span>
<span class="sd">        select:         Model grid nodes to consider</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get closest plane to points</span>
    <span class="n">n_sets</span> <span class="o">=</span> <span class="n">dip_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>                   <span class="c1"># Number of planes</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">xtemp</span><span class="o">.</span><span class="n">shape</span>                       <span class="c1"># Get number of model cells</span>
    <span class="n">set_no</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>  <span class="c1"># Initialise set number array</span>
    <span class="n">z_dip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x_dip</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">znow</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">xtemp</span><span class="p">[</span><span class="n">select</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">ytemp</span><span class="p">[</span><span class="n">select</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">ztemp</span><span class="p">[</span><span class="n">select</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span>      <span class="c1"># Cartesian coordinates of model grid nodes</span>
    <span class="n">plp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x_dip</span><span class="p">,</span> <span class="n">y_dip</span><span class="p">,</span> <span class="n">z_dip</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>                                     <span class="c1"># Cartesian coordinates of points on dip planes</span>
    <span class="n">pd</span> <span class="o">=</span> <span class="n">plp</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="o">.</span><span class="n">T</span>                                                <span class="c1"># subtract grid nodes from plane points</span>

    <span class="n">select_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>                                               <span class="c1"># Get indices of selected model nodes</span>

    <span class="c1"># Loop over set planes</span>
    <span class="k">for</span> <span class="n">iset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sets</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">abc_1</span> <span class="o">=</span> <span class="n">dip_norm</span><span class="p">[:,</span> <span class="n">iset</span><span class="p">]</span>                                                           <span class="c1"># Plane normal equation</span>
        <span class="n">pd_1</span> <span class="o">=</span> <span class="n">abc_1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="n">iset</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">abc_1</span> <span class="o">*</span> <span class="n">abc_1</span><span class="p">))</span>          <span class="c1"># Distance to plane</span>
        <span class="n">pd1_c1</span> <span class="o">=</span> <span class="n">pd_1</span> <span class="o">&lt;=</span> <span class="mi">0</span>                                                                  <span class="c1"># pd_1 meeting condition 1</span>
        <span class="n">pd1_c1_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pd1_c1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">iset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">set_no</span><span class="p">[</span><span class="n">select_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">pd1_c1_idx</span><span class="p">],</span> <span class="n">select_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">pd1_c1_idx</span><span class="p">],</span> <span class="n">select_idx</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">pd1_c1_idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">iset</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">iset</span> <span class="o">==</span> <span class="n">n_sets</span><span class="p">:</span>
            <span class="n">pd1_c2_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pd_1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>                     <span class="c1"># index of pd_2 meeting condition 1</span>
            <span class="n">set_no</span><span class="p">[</span><span class="n">select_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">pd1_c2_idx</span><span class="p">],</span> <span class="n">select_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">pd1_c2_idx</span><span class="p">],</span> <span class="n">select_idx</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">pd1_c2_idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">iset</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">abc_2</span> <span class="o">=</span> <span class="n">dip_norm</span><span class="p">[:,</span> <span class="n">iset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Points on plane</span>
            <span class="n">pd_2</span> <span class="o">=</span> <span class="n">abc_2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="n">iset</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">abc_2</span> <span class="o">*</span> <span class="n">abc_2</span><span class="p">))</span>  <span class="c1"># Distance to plane</span>
            <span class="n">inset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">pd_1</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pd_2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>                                   <span class="c1"># grid cell between planes</span>
            <span class="n">set_no</span><span class="p">[</span><span class="n">select_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">inset</span><span class="p">],</span> <span class="n">select_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">inset</span><span class="p">],</span> <span class="n">select_idx</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">inset</span><span class="p">]]</span> <span class="o">=</span> <span class="n">iset</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">set_no</span></div>


<span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">Testing functions</span>
<span class="sd">--------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># param = &#39;../parameter_files/singletrough.ini&#39;</span>
    <span class="n">param</span> <span class="o">=</span> <span class="s1">&#39;../runfiles/herten/herten.ini&#39;</span>
    <span class="c1"># param = &#39;../runfiles/herten/testing_big_parameters.ini&#39;</span>
    <span class="c1"># param = &#39;../runfiles/made/made.ini&#39;</span>
    <span class="c1"># param = &#39;../runfiles/display/dipset_parameters.ini&#39;</span>
    <span class="c1"># param = &#39;../runfiles/display/single_channel.ini&#39;</span>

    <span class="c1"># param = &#39;E:/Repositories/hfm_flowtrans/runfiles/block/parameters.ini&#39;</span>
    <span class="c1"># param = &#39;../runfiles/display/multisheet.ini&#39;</span>
    <span class="n">hyvr_main</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">hs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># channel_checker(param, &#39;me_channel&#39;)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">HYVR 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Jeremy Bennett.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>