<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>hyvr.sim &#8212; HYVR 0.2 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="HYVR 0.2 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">HYVR 0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for hyvr.sim</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot; Hydrogeological Virtual Reality simulation package.</span>

<span class="sd">    Hydrogeological virtual reality (HYVR) simulator for object-based modelling</span>
<span class="sd">    of sedimentary structures</span>

<span class="sd">    :Author: Jeremy P. Bennett</span>

<span class="sd">    :Notes:</span>
<span class="sd">         Grid nodes are cell-centred!</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="nn">sio</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">h5py</span>

<span class="kn">import</span> <span class="nn">hyvr.grid</span> <span class="k">as</span> <span class="nn">gr</span>
<span class="kn">import</span> <span class="nn">hyvr.utils</span> <span class="k">as</span> <span class="nn">hu</span>
<span class="kn">import</span> <span class="nn">hyvr.optimized</span> <span class="k">as</span> <span class="nn">ho</span>
<span class="kn">import</span> <span class="nn">hyvr.parameters</span> <span class="k">as</span> <span class="nn">hp</span>


<div class="viewcode-block" id="run"><a class="viewcode-back" href="../../modules.html#hyvr.sim.run">[docs]</a><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">param_file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Main function for HYVR generation</span>

<span class="sd">    Parameters:</span>
<span class="sd">        param_file (str): 	Parameter file location</span>

<span class="sd">    Returns:</span>

<span class="sd">        Save data outputs as parameter file</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">param_file</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">param_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span> <span class="n">__file__</span> <span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">pardir</span><span class="p">,</span> <span class="s1">&#39;testcases&#39;</span><span class="p">,</span> <span class="s1">&#39;made.ini&#39;</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;param file:&#39;</span><span class="p">,</span> <span class="n">param_file</span><span class="p">)</span>

    <span class="c1"># Load parameter file</span>
    <span class="n">run</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">strata</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">,</span> <span class="n">flowtrans</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">mg</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">model_setup</span><span class="p">(</span><span class="n">param_file</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">run</span><span class="p">[</span><span class="s1">&#39;numsim&#39;</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Generate facies</span>
        <span class="n">props</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">facies</span><span class="p">(</span><span class="n">run</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">strata</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">,</span> <span class="n">flowtrans</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">mg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;gen&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Generate internal heterogeneity</span>
            <span class="n">props</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">heterogeneity</span><span class="p">(</span><span class="n">props</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="c1"># Save data</span>
        <span class="k">if</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;numsim&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">realname</span> <span class="o">=</span> <span class="s1">&#39;real_</span><span class="si">{:03d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
            <span class="n">realdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">run</span><span class="p">[</span><span class="s1">&#39;rundir&#39;</span><span class="p">],</span> <span class="n">realname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">realname</span> <span class="o">=</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;runname&#39;</span><span class="p">]</span>
            <span class="n">realdir</span> <span class="o">=</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;rundir&#39;</span><span class="p">]</span>

        <span class="n">hu</span><span class="o">.</span><span class="n">try_makefolder</span><span class="p">(</span><span class="n">realdir</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;dataoutputs&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;gen&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">outdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;fac&#39;</span><span class="p">],</span> <span class="s1">&#39;azim&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;azim&#39;</span><span class="p">],</span> <span class="s1">&#39;dip&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">],</span>
                           <span class="s1">&#39;k_iso&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;k_iso&#39;</span><span class="p">],</span> <span class="s1">&#39;poros&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;poros&#39;</span><span class="p">],</span> <span class="s1">&#39;ae&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;ae_arr&#39;</span><span class="p">],</span>
                           <span class="s1">&#39;ha&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;ha_arr&#39;</span><span class="p">],</span> <span class="s1">&#39;hat&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;hat_arr&#39;</span><span class="p">],</span> <span class="s1">&#39;ssm&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;ssm_arr&#39;</span><span class="p">],</span> <span class="s1">&#39;anirat&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;anirat&#39;</span><span class="p">],</span>
                           <span class="s1">&#39;ktensors&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;ktensors&#39;</span><span class="p">],</span> <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;fac&#39;</span><span class="p">],</span> <span class="s1">&#39;azim&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;azim&#39;</span><span class="p">],</span> <span class="s1">&#39;dip&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">],</span>
                           <span class="s1">&#39;ae&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;ae_arr&#39;</span><span class="p">],</span> <span class="s1">&#39;ha&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;ha_arr&#39;</span><span class="p">],</span> <span class="s1">&#39;hat&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;hat_arr&#39;</span><span class="p">],</span>
                           <span class="s1">&#39;ssm&#39;</span><span class="p">:</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;ssm_arr&#39;</span><span class="p">]}</span>
            <span class="n">save_outputs</span><span class="p">(</span><span class="n">realdir</span><span class="p">,</span> <span class="n">realname</span><span class="p">,</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;dataoutputs&#39;</span><span class="p">],</span> <span class="n">mg</span><span class="p">,</span> <span class="n">outdict</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;modeloutputs&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;gen&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No hydraulic parameters generated. No model outputs saved&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">save_models</span><span class="p">(</span><span class="n">realdir</span><span class="p">,</span> <span class="n">realname</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;modeloutputs&#39;</span><span class="p">],</span> <span class="n">flowtrans</span><span class="p">,</span>
                            <span class="n">props</span><span class="p">[</span><span class="s1">&#39;k_iso&#39;</span><span class="p">],</span>
                            <span class="n">props</span><span class="p">[</span><span class="s1">&#39;ktensors&#39;</span><span class="p">],</span>
                            <span class="n">props</span><span class="p">[</span><span class="s1">&#39;poros&#39;</span><span class="p">],</span>
                            <span class="n">props</span><span class="p">[</span><span class="s1">&#39;anirat&#39;</span><span class="p">],</span>
                            <span class="n">props</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">],</span>
                            <span class="n">props</span><span class="p">[</span><span class="s1">&#39;azim&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="facies"><a class="viewcode-back" href="../../modules.html#hyvr.sim.facies">[docs]</a><span class="k">def</span> <span class="nf">facies</span><span class="p">(</span><span class="n">run</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">strata</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">,</span> <span class="n">flowtrans</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">mg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;  Generate hydrofacies fields</span>

<span class="sd">    Parameters:</span>
<span class="sd">        run:					Model run parameters like ``runname``, ``rundir``, ``l_dataoutputs``, ``l_modeloutputs``, etc.</span>
<span class="sd">        model:					Model domain parameters</span>
<span class="sd">        strata:				Details about the strata</span>
<span class="sd">        hydraulics:				Details about the hydraulics</span>
<span class="sd">        flowtrans:				Flow &amp; transport simulation parameters</span>
<span class="sd">        elements:				Architectural elements and parameters</span>
<span class="sd">        mg:						Mesh grid object class</span>

<span class="sd">    Returns:</span>
<span class="sd">        (tuple): Tuple containing:</span>

<span class="sd">         - probs *(dict)*: Contains data of architectural element units and associated hydrofacies</span>

<span class="sd">        - params *(tuple)* - Contains parameters of model domain, strata, hydraulics, etc.</span>
<span class="sd">            - run (dict) - Model run parameters</span>
<span class="sd">            - model (dict) - Model domain parameters</span>
<span class="sd">            - strata (dict) - Strata parameters</span>
<span class="sd">            - hydraulics (dict) - Hydraulic properties parameters</span>
<span class="sd">            - flowtrans (dict) - Flow &amp; transport simulation parameters</span>
<span class="sd">            - elements (dict) - Architectural elements and parameters</span>
<span class="sd">            - mg - Mesh grid object class</span>
<span class="sd">            - ae_lu - Architectural element lookup table</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">    Simulate system contacts</span>
<span class="sd">    --------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>
    <span class="n">num_ssm</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">num_ssm</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Create contact surfaces &quot;&quot;&quot;</span>
        <span class="n">z_bot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span>
        <span class="n">ssm_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># Initialise system storage array</span>
        <span class="n">ssm_top_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">num_ssm</span><span class="p">))</span>
        <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_bot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_ssm</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">zzz</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">meshup</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ssm</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_contact&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span> <span class="ow">and</span> <span class="n">si</span> <span class="o">!=</span> <span class="n">num_ssm</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_contact_model&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span>       <span class="c1"># geostatistical parameters of system</span>

                <span class="c1"># Generate random top contact</span>
                <span class="n">z_top</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">specsim</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sp</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">twod</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">covmod</span><span class="o">=</span><span class="s1">&#39;gau&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_top&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span>
                <span class="n">z_top</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">round_x</span><span class="p">(</span><span class="n">z_top</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">model</span><span class="p">[</span><span class="s1">&#39;dz&#39;</span><span class="p">])</span>           <span class="c1"># round the values to grid resolution</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Flat top contact</span>
                <span class="n">z_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span> <span class="o">*</span> <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_top&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span>

            <span class="c1"># Update lowest and highest values due to randomness</span>
            <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_bot&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z_bot</span><span class="p">),</span> <span class="n">mg</span><span class="o">.</span><span class="n">oz</span><span class="p">])</span>
            <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_top&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z_top</span><span class="p">),</span> <span class="n">mg</span><span class="o">.</span><span class="n">oz</span> <span class="o">+</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">])</span>

            <span class="c1"># Assign z_bot and z_top values to entire array</span>
            <span class="n">z_bot_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">z_bot</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">])</span>
            <span class="n">z_top_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">z_top</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">])</span>
            <span class="n">zae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">zzz</span> <span class="o">&gt;=</span> <span class="n">z_bot_arr</span><span class="p">,</span> <span class="n">zzz</span> <span class="o">&lt;</span> <span class="n">z_top_arr</span><span class="p">)</span>
            <span class="n">ssm_arr</span><span class="p">[</span><span class="n">zae</span><span class="p">]</span> <span class="o">=</span> <span class="n">si</span>

            <span class="n">z_bot</span> <span class="o">=</span> <span class="n">z_top</span>                   <span class="c1"># Update lower contact surface elevation</span>
            <span class="n">ssm_top_z</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_top</span>     <span class="c1"># Assign system top to storage array</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Only one system present</span>
        <span class="n">ssm_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># Initialise system storage array</span>
        <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_bot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">mg</span><span class="o">.</span><span class="n">oz</span><span class="p">]</span>
        <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">mg</span><span class="o">.</span><span class="n">oz</span> <span class="o">+</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">]</span>

    <span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">    Simulate architectural element units</span>
<span class="sd">    --------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ae_table&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Load architectural element lookup table (same directory as ini parameter input file &quot;&quot;&quot;</span>
        <span class="n">ae_lu</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">read_lu</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">run</span><span class="p">[</span><span class="s1">&#39;modeldir&#39;</span><span class="p">],</span><span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ae_table&#39;</span><span class="p">]))</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ae_z_mean&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Uniform Model &quot;&quot;&quot;</span>
        <span class="n">ae_lu</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">,</span> <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_ae&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]]]</span>
        <span class="n">ae_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># Initialise system storage array</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Assign architectural element units &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: Generating architectural element unit contacts&#39;</span><span class="p">)</span>

        <span class="c1"># Initialise architectural element unit lookup table</span>
        <span class="c1"># [architectural element unit #, z_bottom, z_top, architectural element type, system #</span>
        <span class="n">ae_lu</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_top&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Final major strata elevation and uppermost model grid elevation do not match.</span><span class="se">\n</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;Please update model.lz or strata.r_ssm_top.&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm&#39;</span><span class="p">])):</span>
            <span class="c1"># Randomly assign strata / architectural element contact surfaces</span>
            <span class="n">znow</span> <span class="o">=</span> <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_bot&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">znow</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">,</span> <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_top&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]]):</span>
                <span class="c1"># Loop over all depths in system</span>
                <span class="n">aelu_z</span> <span class="o">=</span> <span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="n">znow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">si</span><span class="p">]</span>       <span class="c1"># Initialise AE entry in lookup table (and assign identifier)</span>

                <span class="c1"># Assign architectural element</span>
                <span class="n">aelu_z</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob_choose</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_ae&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">],</span>
                                        <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ae_prob&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">])</span>

                <span class="c1"># Assign unit thickness</span>
                <span class="n">ae_z_mean</span> <span class="o">=</span> <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ae_z_mean&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">][</span><span class="n">strata</span><span class="p">[</span><span class="s1">&#39;ssm_ae&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">aelu_z</span><span class="p">[</span><span class="mi">3</span><span class="p">])]</span>
                <span class="n">ae_z</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">round_x</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">ae_z_mean</span><span class="p">,</span> <span class="n">ae_z_mean</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">base</span><span class="o">=</span><span class="n">model</span><span class="p">[</span><span class="s1">&#39;dz&#39;</span><span class="p">])</span>
                <span class="n">aelu_z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ae_z</span> <span class="o">+</span> <span class="n">znow</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">)</span>

                <span class="c1"># Assign avulsion</span>
                <span class="n">avul_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="s1">&#39;avul_prob&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">])</span>
                <span class="n">yn</span> <span class="o">=</span> <span class="n">prob_choose</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">avul_prob</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">avul_prob</span><span class="p">])</span>         <span class="c1"># Avulsion yes/no</span>
                <span class="n">avudr</span> <span class="o">=</span> <span class="n">strata</span><span class="p">[</span><span class="s1">&#39;avul&#39;</span><span class="p">][</span><span class="n">si</span><span class="p">]</span>      <span class="c1"># Avulsion depth range for system</span>
                <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">avudr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">avudr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">yn</span>
                <span class="n">znow</span> <span class="o">+=</span> <span class="n">ae_z</span> <span class="o">+</span> <span class="n">dz</span>

                <span class="c1"># Append to lookup table</span>
                <span class="n">ae_lu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aelu_z</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="sd">&quot;&quot;&quot; Create contact surfaces &quot;&quot;&quot;</span>
    <span class="n">z_bot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span>
    <span class="n">ae_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># Initialise system storage array</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">zzz</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">meshup</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">ae_i</span><span class="p">,</span> <span class="n">ae_z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ae_lu</span><span class="p">):</span>
        <span class="n">ae_dict</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">ae_z</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>                             <span class="c1"># Get architectural element dict</span>
        <span class="k">if</span> <span class="n">ae_i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ae_lu</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If AE  is the upper-most in the domain</span>
            <span class="n">z_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span> <span class="o">*</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span>             <span class="c1"># Assign domain top as unit top</span>
        <span class="k">elif</span> <span class="n">ae_lu</span><span class="p">[</span><span class="n">ae_i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ae_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># Use the system top contact if the AE unit is the top-most in the system</span>
            <span class="n">z_top</span> <span class="o">=</span> <span class="n">ssm_top_z</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ae_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">ae_dict</span><span class="p">[</span><span class="s1">&#39;contact&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ae_dict</span><span class="p">[</span><span class="s1">&#39;contact&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="c1"># Generate random top contact</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">ae_dict</span><span class="p">[</span><span class="s1">&#39;contact_model&#39;</span><span class="p">]</span>
            <span class="n">z_top</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">specsim</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sp</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">twod</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">covmod</span><span class="o">=</span><span class="s1">&#39;gau&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">ae_z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">z_top</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">round_x</span><span class="p">(</span><span class="n">z_top</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">model</span><span class="p">[</span><span class="s1">&#39;dz&#39;</span><span class="p">])</span>           <span class="c1"># round the values to grid resolution</span>
            <span class="n">ae_z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z_top</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Flat top contact</span>
            <span class="n">z_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span> <span class="o">*</span> <span class="n">ae_z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Assign z_bot and z_top values to entire array</span>
        <span class="n">z_bot_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">z_bot</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">])</span>
        <span class="n">z_top_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">z_top</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">])</span>
        <span class="n">zae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">zzz</span> <span class="o">&gt;=</span> <span class="n">z_bot_arr</span><span class="p">,</span> <span class="n">zzz</span> <span class="o">&lt;</span> <span class="n">z_top_arr</span><span class="p">)</span>
        <span class="n">zae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">zae</span><span class="p">,</span> <span class="n">ssm_arr</span> <span class="o">==</span> <span class="n">ae_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ae_arr</span><span class="p">[</span><span class="n">zae</span><span class="p">]</span> <span class="o">=</span> <span class="n">ae_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Hack to make sure erosive elements aren&#39;t simulated in strata below</span>
        <span class="k">if</span> <span class="n">ae_dict</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;trunc_ellip&#39;</span><span class="p">,</span> <span class="s1">&#39;channel&#39;</span><span class="p">,</span> <span class="s1">&#39;ext_par&#39;</span><span class="p">]:</span>
            <span class="n">ae_lu</span><span class="p">[</span><span class="n">ae_i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z_bot</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>            <span class="c1"># Update AE lookup table with highest value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ae_lu</span><span class="p">[</span><span class="n">ae_i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z_bot</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>            <span class="c1"># Update AE lookup table with lowest value</span>

        <span class="n">z_bot</span> <span class="o">=</span> <span class="n">z_top</span>           <span class="c1"># Update lower contact surface elevation</span>

    <span class="c1"># Save system lookup table</span>
    <span class="c1"># if &#39;ae_table&#39; not in strata:</span>
    <span class="c1">#     lu_savetxt = rundir + &#39;/ae_lu_&#39; + time.strftime(&#39;%d-%m-%Y_%H.%M.%S.txt&#39;)</span>
    <span class="c1">#     with open(lu_savetxt, &#39;w&#39;) as fwr:</span>
    <span class="c1">#         print(&#39;strata summary&#39;)</span>
    <span class="c1">#         for i in ae_lu:</span>
    <span class="c1">#             fwr.write(&#39;%s\n&#39; % str()[1:-1])</span>
    <span class="c1">#             print(i)</span>

    <span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">    Hydrofacies simulation</span>
<span class="sd">    --------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>
    <span class="c1"># Initialise storage arrays</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">hat_arr</span><span class="p">,</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="n">azim</span><span class="p">,</span> <span class="n">dip</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">bg</span><span class="o">=</span><span class="n">strata</span><span class="p">[</span><span class="s1">&#39;bg&#39;</span><span class="p">],</span> <span class="n">mat_count</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot; Create architectural elements and associated hydrofacies fields &quot;&quot;&quot;</span>
    <span class="c1"># Loop over AE units rather than elevations</span>
    <span class="k">for</span> <span class="n">ae_i</span> <span class="ow">in</span> <span class="n">ae_lu</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: generating &#39;</span> <span class="o">+</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; from &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ae_i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;m&#39;</span><span class="p">)</span>
        <span class="n">ae_dict</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">ae_i</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">ae_dict</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;trunc_ellip&#39;</span><span class="p">:</span>
            <span class="c1"># Generate truncated ellipsoid</span>
            <span class="n">props_n</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">gen_trough</span><span class="p">(</span><span class="n">ae_dict</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">ae_i</span><span class="p">,</span> <span class="n">ae_arr</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
            <span class="n">ae_mask</span> <span class="o">=</span> <span class="n">props_n</span><span class="p">[</span><span class="s1">&#39;ae_arr_i&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">ae_dict</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ext_par&#39;</span><span class="p">,</span> <span class="s1">&#39;channel&#39;</span><span class="p">]:</span>
            <span class="c1"># Generate extruded parabola</span>
            <span class="n">props_n</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">gen_extpar</span><span class="p">(</span><span class="n">ae_dict</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">ae_i</span><span class="p">,</span> <span class="n">ae_arr</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
            <span class="n">ae_mask</span> <span class="o">=</span> <span class="n">props_n</span><span class="p">[</span><span class="s1">&#39;ae_arr_i&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">ae_dict</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;sheet&#39;</span><span class="p">:</span>
            <span class="c1"># Generate sheet</span>
            <span class="n">props_n</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">gen_sheet</span><span class="p">(</span><span class="n">ae_dict</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">ae_i</span><span class="p">,</span> <span class="n">ae_arr</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
            <span class="n">ae_mask</span> <span class="o">=</span> <span class="n">ae_arr</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="sd">&quot;&quot;&quot; ADD NEW GEOMETRIES HERE &quot;&quot;&quot;</span>

        <span class="c1"># Assign simulated values to storage arrays</span>
        <span class="n">ae_arr</span><span class="p">[</span><span class="n">ae_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ssm_arr</span><span class="p">[</span><span class="n">ae_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">hat_arr</span><span class="p">[</span><span class="n">ae_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">props_n</span><span class="p">[</span><span class="s1">&#39;hat_arr&#39;</span><span class="p">][</span><span class="n">ae_mask</span><span class="p">]</span>
        <span class="n">ha_arr</span><span class="p">[</span><span class="n">ae_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">props_n</span><span class="p">[</span><span class="s1">&#39;ha_arr&#39;</span><span class="p">][</span><span class="n">ae_mask</span><span class="p">]</span>
        <span class="n">fac</span><span class="p">[</span><span class="n">ae_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">props_n</span><span class="p">[</span><span class="s1">&#39;fac&#39;</span><span class="p">][</span><span class="n">ae_mask</span><span class="p">]</span>
        <span class="n">azim</span><span class="p">[</span><span class="n">ae_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">props_n</span><span class="p">[</span><span class="s1">&#39;azim&#39;</span><span class="p">][</span><span class="n">ae_mask</span><span class="p">]</span>
        <span class="n">dip</span><span class="p">[</span><span class="n">ae_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">props_n</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">][</span><span class="n">ae_mask</span><span class="p">]</span>

    <span class="c1"># Renumber material values from zero to remove eroded values</span>
    <span class="n">ha_arr</span> <span class="o">=</span> <span class="n">ho</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">ha_arr</span><span class="p">)</span>

    <span class="c1"># Wrap storage arrays in a dictionary</span>
    <span class="k">if</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;anisotropy&#39;</span><span class="p">]:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;azim&#39;</span><span class="p">:</span> <span class="n">azim</span><span class="p">,</span> <span class="s1">&#39;ha_arr&#39;</span><span class="p">:</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="s1">&#39;hat_arr&#39;</span><span class="p">:</span> <span class="n">hat_arr</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">:</span> <span class="n">dip</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;ae_arr&#39;</span><span class="p">:</span> <span class="n">ae_arr</span><span class="p">,</span> <span class="s1">&#39;ssm_arr&#39;</span><span class="p">:</span> <span class="n">ssm_arr</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ha_arr&#39;</span><span class="p">:</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;hat_arr&#39;</span><span class="p">:</span> <span class="n">hat_arr</span><span class="p">,</span> <span class="s1">&#39;ae_arr&#39;</span><span class="p">:</span> <span class="n">ae_arr</span><span class="p">,</span> <span class="s1">&#39;ssm_arr&#39;</span><span class="p">:</span> <span class="n">ssm_arr</span><span class="p">}</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">run</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">strata</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">,</span> <span class="n">flowtrans</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">ae_lu</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">props</span><span class="p">,</span> <span class="n">params</span></div>


<div class="viewcode-block" id="heterogeneity"><a class="viewcode-back" href="../../modules.html#hyvr.sim.heterogeneity">[docs]</a><span class="k">def</span> <span class="nf">heterogeneity</span><span class="p">(</span><span class="n">props</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate internal heterogeneity</span>

<span class="sd">    Parameters:</span>
<span class="sd">        probs (list):			Data of architectural element units and associated hydrofacies (e.g. values of azimuth, material, dipping, etc.)</span>
<span class="sd">        params (list):			Parameters of model domain, system, hydraulics, etc.</span>

<span class="sd">    Returns:</span>
<span class="sd">        - probs *(list)* - Data of architectural element units and associated hydrofacies</span>
<span class="sd">        - params *(list)* - Input parameters, assigned with heterogenity</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: generating hydraulic parameters&#39;</span><span class="p">)</span>
    <span class="n">run</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">strata</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">,</span> <span class="n">flowtrans</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">ae_lu</span> <span class="o">=</span> <span class="n">params</span>


    <span class="n">ha_arr</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;ha_arr&#39;</span><span class="p">]</span>
    <span class="n">fac</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;fac&#39;</span><span class="p">]</span>
    <span class="n">ae_arr</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;ae_arr&#39;</span><span class="p">]</span>
    <span class="n">hat_arr</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;hat_arr&#39;</span><span class="p">]</span>
    <span class="n">ssm_arr</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;ssm_arr&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;anisotropy&#39;</span><span class="p">]:</span>
        <span class="n">azim</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;azim&#39;</span><span class="p">]</span>
        <span class="n">dip</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">azim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">dip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="c1"># Initialise storage arrays</span>
    <span class="n">k_iso</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>       <span class="c1"># Horizontal hydraulic conductivity array</span>
    <span class="n">poros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>       <span class="c1"># Porosity array</span>
    <span class="n">anirat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>       <span class="c1"># K_h/K_v anisotropy ratio</span>

    <span class="k">if</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;het&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Heterogeneous case</span>
        <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ha_arr</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">fac</span><span class="p">[</span><span class="n">ha_arr</span> <span class="o">==</span> <span class="n">mi</span><span class="p">]):</span>
                <span class="n">mifi</span> <span class="o">=</span> <span class="p">(</span><span class="n">ha_arr</span> <span class="o">==</span> <span class="n">mi</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fac</span> <span class="o">==</span> <span class="n">fi</span><span class="p">)</span>    <span class="c1"># Get mask for relevant values</span>

                <span class="k">if</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;hetlev&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
                    <span class="c1"># Generate internal heterogeneity</span>
                    <span class="c1"># Find outer limit of facies</span>
                    <span class="n">fac_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mifi</span><span class="p">)</span>                                <span class="c1"># Get indices of facies</span>
                    <span class="n">fac_nx</span> <span class="o">=</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>        <span class="c1"># Get number of grid cells in x-direction</span>
                    <span class="n">fac_ny</span> <span class="o">=</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>        <span class="c1"># Get number of grid cells in y-direction</span>
                    <span class="n">fac_nz</span> <span class="o">=</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>        <span class="c1"># Get number of grid cells in z-direction</span>

                    <span class="c1"># Generate field with matching size</span>
                    <span class="c1"># Should include a condition that considers the characteristic lengths of the features</span>
                    <span class="n">temp_gr</span> <span class="o">=</span> <span class="n">gr</span><span class="o">.</span><span class="n">Grid</span><span class="p">(</span><span class="n">dx</span><span class="o">=</span><span class="n">mg</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="n">mg</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="o">=</span><span class="n">mg</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">fac_nx</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">fac_ny</span><span class="p">,</span> <span class="n">nz</span><span class="o">=</span><span class="n">fac_nz</span><span class="p">,</span> <span class="n">gtype</span><span class="o">=</span><span class="s1">&#39;cells&#39;</span><span class="p">)</span>

                    <span class="c1"># Generate internal heterogeneity - hydraulic conductivity</span>
                    <span class="n">temp_k_small</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">specsim</span><span class="p">(</span><span class="n">temp_gr</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;sig_y&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">],</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;ycorlengths&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">],</span> <span class="n">covmod</span><span class="o">=</span><span class="s1">&#39;exp&#39;</span><span class="p">)</span>
                    <span class="n">temp_k_small</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">temp_k_small</span><span class="p">)</span> <span class="o">*</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_h&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>          <span class="c1"># back-transform from log space</span>
                    <span class="n">temp_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

                    <span class="c1"># Nest smaller array into larger array</span>
                    <span class="c1"># Get coordinates for &#39;nesting&#39;</span>
                    <span class="n">ix1</span> <span class="o">=</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k_small</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">iy1</span> <span class="o">=</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="n">iy2</span> <span class="o">=</span> <span class="n">iy1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k_small</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">iz1</span> <span class="o">=</span> <span class="n">fac_idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="n">iz2</span> <span class="o">=</span> <span class="n">iz1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k_small</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">iy1</span><span class="p">:</span><span class="n">iy2</span><span class="p">,</span> <span class="n">iz1</span><span class="p">:</span><span class="n">iz2</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k_small</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="c1"># QnD way to avoid indexing issues with nesting of the random field</span>
                        <span class="n">ix1</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">ix2</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">iy1</span><span class="p">:</span><span class="n">iy2</span><span class="p">,</span> <span class="n">iz1</span><span class="p">:</span><span class="n">iz2</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k_small</span><span class="p">)[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="c1"># QnD way to avoid indexing issues with nesting of the random field</span>
                        <span class="n">iy1</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">iy2</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">iy1</span><span class="p">:</span><span class="n">iy2</span><span class="p">,</span> <span class="n">iz1</span><span class="p">:</span><span class="n">iz2</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">temp_k_small</span><span class="p">)[</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="c1"># QnD way to avoid indexing issues with nesting of the random field</span>
                        <span class="n">iz1</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">iz2</span> <span class="o">-=</span> <span class="mi">1</span>

                    <span class="c1"># Insert into full-size array</span>
                    <span class="n">temp_k</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">iy1</span><span class="p">:</span><span class="n">iy2</span><span class="p">,</span> <span class="n">iz1</span><span class="p">:</span><span class="n">iz2</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_k_small</span>
                    <span class="n">k_iso</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_k</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span>

                    <span class="c1"># Generate internal heterogeneity - porosity</span>
                    <span class="n">temp_n_small</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">specsim</span><span class="p">(</span><span class="n">temp_gr</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;sig_n&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">],</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;ncorlengths&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">],</span> <span class="n">covmod</span><span class="o">=</span><span class="s1">&#39;exp&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>
                    <span class="n">temp_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                    <span class="c1"># Nest smaller array into larger array</span>
                    <span class="n">temp_n</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">iy1</span><span class="p">:</span><span class="n">iy2</span><span class="p">,</span> <span class="n">iz1</span><span class="p">:</span><span class="n">iz2</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_n_small</span>
                    <span class="n">poros</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_n</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span>

                <span class="k">elif</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;hetlev&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;facies&#39;</span><span class="p">:</span>
                    <span class="c1"># Assign heterogeneity at facies level only</span>
                    <span class="n">k_iso</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_h&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>
                    <span class="n">poros</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>

                <span class="c1"># Assign anisotropy ratio</span>
                <span class="n">anirat</span><span class="p">[</span><span class="n">mifi</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_ratio&#39;</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>

        <span class="sd">&quot;&quot;&quot; Assign background heterogeneity per architectural element &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;hetlev&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">aei</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ae_lu</span><span class="p">):</span>
                <span class="n">m0</span> <span class="o">=</span> <span class="n">ha_arr</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="n">ms</span> <span class="o">=</span> <span class="n">ae_arr</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">aei</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">aemask</span> <span class="o">=</span> <span class="n">m0</span> <span class="o">&amp;</span> <span class="n">ms</span>     <span class="c1"># Get material that equals zero within in architectural element</span>
                <span class="k">if</span> <span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="s1">&#39;bg&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">aebackfac</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="s1">&#39;bg&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>   <span class="c1"># architectural element background facies</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aebackfac</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="s1">&#39;bg&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># Assign background material</span>
                <span class="n">temp_k</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">specsim</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;sig_y&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">],</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;ycorlengths&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">],</span> <span class="n">covmod</span><span class="o">=</span><span class="s1">&#39;exp&#39;</span><span class="p">)</span>
                <span class="n">temp_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">temp_k</span><span class="p">)</span> <span class="o">*</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_h&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">]</span>          <span class="c1"># back-transform from log space</span>
                <span class="n">k_iso</span><span class="p">[</span><span class="n">aemask</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_k</span><span class="p">[</span><span class="n">aemask</span><span class="p">]</span>

                <span class="c1"># Generate internal heterogeneity - porosity</span>
                <span class="n">temp_n</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">specsim</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;sig_n&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">],</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;ncorlengths&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">],</span> <span class="n">covmod</span><span class="o">=</span><span class="s1">&#39;exp&#39;</span><span class="p">)</span>
                <span class="n">temp_n</span> <span class="o">=</span> <span class="n">temp_n</span> <span class="o">+</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">]</span>
                <span class="n">poros</span><span class="p">[</span><span class="n">aemask</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_n</span><span class="p">[</span><span class="n">aemask</span><span class="p">]</span>

                <span class="c1"># Assign background anisotropy ratio</span>
                <span class="n">anirat</span><span class="p">[</span><span class="n">aemask</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_ratio&#39;</span><span class="p">][</span><span class="n">aebackfac</span><span class="p">]</span>

                <span class="c1"># Assign architectural element trends</span>
                <span class="k">if</span> <span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="s1">&#39;k_ztrend&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Vertical trend</span>
                    <span class="n">zf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="s1">&#39;k_ztrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="s1">&#39;k_ztrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">)</span>  <span class="c1"># Z factor at each elevation</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Longitudinal trend</span>
                    <span class="n">zf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">,))</span>
                <span class="k">if</span> <span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="s1">&#39;k_xtrend&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">xf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="s1">&#39;k_xtrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">elements</span><span class="p">[</span><span class="n">aei</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="s1">&#39;k_xtrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,))</span>
                <span class="n">k_iso</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">k_iso</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">xf_vec</span><span class="p">)</span>
                <span class="n">k_iso</span> <span class="o">*=</span> <span class="n">zf_vec</span>

            <span class="sd">&quot;&quot;&quot; Assign trends to hydraulic parameters globally &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_ztrend&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">zf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_ztrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_ztrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">)</span>  <span class="c1"># Z factor at each elevation</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Longitudinal trend</span>
                <span class="n">zf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">,))</span>
            <span class="k">if</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_xtrend&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_xtrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_xtrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,))</span>
            <span class="n">k_iso</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">k_iso</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">xf_vec</span><span class="p">)</span>
            <span class="n">k_iso</span> <span class="o">*=</span> <span class="n">zf_vec</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Homogeneous case</span>
        <span class="k">for</span> <span class="n">hy_idx</span><span class="p">,</span> <span class="n">hyi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;hydro&#39;</span><span class="p">]):</span>
            <span class="n">hyi</span> <span class="o">=</span> <span class="n">hy_idx</span>
            <span class="n">k_iso</span><span class="p">[</span><span class="n">fac</span> <span class="o">==</span> <span class="n">hyi</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_h&#39;</span><span class="p">][</span><span class="n">hy_idx</span><span class="p">]</span>
            <span class="n">poros</span><span class="p">[</span><span class="n">fac</span> <span class="o">==</span> <span class="n">hyi</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">hy_idx</span><span class="p">]</span>
            <span class="n">anirat</span><span class="p">[</span><span class="n">fac</span> <span class="o">==</span> <span class="n">hyi</span><span class="p">]</span> <span class="o">=</span> <span class="n">hydraulics</span><span class="p">[</span><span class="s1">&#39;k_ratio&#39;</span><span class="p">][</span><span class="n">hy_idx</span><span class="p">]</span>

    <span class="sd">&quot;&quot;&quot; Assignment of anisotropy &quot;&quot;&quot;</span>
    <span class="c1"># Initialise storage arrays</span>
    <span class="n">ktensors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="c1"># convert angles to radians</span>
    <span class="n">azim</span> <span class="o">=</span> <span class="n">azim</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">dip</span> <span class="o">=</span> <span class="n">dip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>

    <span class="c1"># Create hydraulic conductivity tensors</span>
    <span class="c1"># kplane = anirat ** 0.5</span>
    <span class="c1"># kperp = 1 / anirat ** 0.5</span>

    <span class="c1"># T =========================</span>
    <span class="c1"># R = np.array([[np.cos(azim), np.sin(azim), 0],</span>
    <span class="c1">#                   [-np.sin(azim), np.cos(azim), 0],</span>
    <span class="c1">#                   [0, 0, 1]], dtype=np.float) * \</span>
    <span class="c1">#         np.array([[np.cos(dip), 0, np.sin(dip)],</span>
    <span class="c1">#                   [0, 1, 0],</span>
    <span class="c1">#                   [-np.sin(dip), 0, np.cos(dip)]], dtype=np.float)</span>
    <span class="c1"># /T =========================</span>

    <span class="c1"># Iterate over all nodes</span>
    <span class="n">ho</span><span class="o">.</span><span class="n">set_anisotropic_ktensor</span><span class="p">(</span><span class="n">ktensors</span><span class="p">,</span> <span class="n">k_iso</span><span class="p">,</span> <span class="n">azim</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">anirat</span><span class="p">)</span>

    <span class="c1"># convert radians to angles</span>
    <span class="n">azim</span> <span class="o">=</span> <span class="n">azim</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">dip</span> <span class="o">=</span> <span class="n">dip</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;azim&#39;</span><span class="p">:</span> <span class="n">azim</span><span class="p">,</span> <span class="s1">&#39;ha_arr&#39;</span><span class="p">:</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">:</span> <span class="n">dip</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;ae_arr&#39;</span><span class="p">:</span> <span class="n">ae_arr</span><span class="p">,</span> <span class="s1">&#39;ssm_arr&#39;</span><span class="p">:</span> <span class="n">ssm_arr</span><span class="p">,</span>
             <span class="s1">&#39;k_iso&#39;</span><span class="p">:</span> <span class="n">k_iso</span><span class="p">,</span> <span class="s1">&#39;ktensors&#39;</span><span class="p">:</span> <span class="n">ktensors</span><span class="p">,</span> <span class="s1">&#39;poros&#39;</span><span class="p">:</span> <span class="n">poros</span><span class="p">,</span> <span class="s1">&#39;anirat&#39;</span><span class="p">:</span> <span class="n">anirat</span><span class="p">,</span> <span class="s1">&#39;hat_arr&#39;</span><span class="p">:</span> <span class="n">hat_arr</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">props</span><span class="p">,</span> <span class="n">params</span></div>


<div class="viewcode-block" id="save_outputs"><a class="viewcode-back" href="../../modules.html#hyvr.sim.save_outputs">[docs]</a><span class="k">def</span> <span class="nf">save_outputs</span><span class="p">(</span><span class="n">realdir</span><span class="p">,</span> <span class="n">realname</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">outdict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save data arrays to standard formats</span>

<span class="sd">    Parameters:</span>
<span class="sd">        realdir (str):  	File path to save to</span>
<span class="sd">        realname (str):  	File name</span>
<span class="sd">        outputs (str):		String codes for what type of outputs should be saved</span>
<span class="sd">        mg:					Mesh grid object class</span>
<span class="sd">        outdict:			Output directory</span>

<span class="sd">    Returns:</span>
<span class="sd">        Save data outputs as .vtk (Paraview), .mat (Matlab) or .dat (Python pickle output)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saving files in </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">realdir</span><span class="p">))</span>
    <span class="n">realname</span> <span class="o">=</span> <span class="n">realname</span> <span class="o">+</span> <span class="s1">&#39;_hyvr&#39;</span>
    <span class="k">if</span> <span class="s1">&#39;vtk&#39;</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
        <span class="c1"># VTK output for visualisation in ParaView</span>
        <span class="n">hu</span><span class="o">.</span><span class="n">to_vtr</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">outdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">outdict</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ktensors&#39;</span><span class="p">]},</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">realdir</span><span class="p">,</span> <span class="n">realname</span><span class="p">),</span> <span class="n">mg</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: VTR export complete&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;mat&#39;</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
        <span class="c1"># MATLAB output</span>
        <span class="n">sio</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">realdir</span><span class="p">,</span> <span class="n">realname</span><span class="p">),</span> <span class="n">outdict</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: Matlab export complete&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;py&#39;</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
        <span class="c1"># Python pickle output</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">realdir</span><span class="p">,</span> <span class="n">realname</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">),</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">outdict</span><span class="p">,</span> <span class="n">outfile</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: Python pickle export complete&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;npz&#39;</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
        <span class="c1"># Numpy .npz</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">realdir</span><span class="p">,</span> <span class="n">realname</span> <span class="o">+</span> <span class="s1">&#39;.npz&#39;</span><span class="p">),</span>
                            <span class="n">ae</span><span class="o">=</span><span class="n">outdict</span><span class="p">[</span><span class="s1">&#39;ae&#39;</span><span class="p">],</span>
                            <span class="n">anirat</span><span class="o">=</span><span class="n">outdict</span><span class="p">[</span><span class="s1">&#39;anirat&#39;</span><span class="p">],</span>
                            <span class="n">azim</span><span class="o">=</span><span class="n">outdict</span><span class="p">[</span><span class="s1">&#39;azim&#39;</span><span class="p">],</span>
                            <span class="n">dip</span><span class="o">=</span><span class="n">outdict</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">],</span>
                            <span class="n">fac</span><span class="o">=</span><span class="n">outdict</span><span class="p">[</span><span class="s1">&#39;fac&#39;</span><span class="p">],</span>
                            <span class="n">ha</span><span class="o">=</span><span class="n">outdict</span><span class="p">[</span><span class="s1">&#39;ha&#39;</span><span class="p">],</span>
                            <span class="n">hat</span><span class="o">=</span><span class="n">outdict</span><span class="p">[</span><span class="s1">&#39;hat&#39;</span><span class="p">],</span>
                            <span class="n">k_iso</span><span class="o">=</span><span class="n">outdict</span><span class="p">[</span><span class="s1">&#39;k_iso&#39;</span><span class="p">],</span>
                            <span class="n">ssm</span><span class="o">=</span><span class="n">outdict</span><span class="p">[</span><span class="s1">&#39;ssm&#39;</span><span class="p">],</span>
                            <span class="n">poros</span><span class="o">=</span><span class="n">outdict</span><span class="p">[</span><span class="s1">&#39;poros&#39;</span><span class="p">],</span>
                            <span class="n">ktensors</span><span class="o">=</span><span class="n">outdict</span><span class="p">[</span><span class="s1">&#39;ktensors&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: Numpy export complete&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;h5&#39;</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
        <span class="c1"># HDF5 format</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">realdir</span><span class="p">,</span> <span class="n">realname</span> <span class="o">+</span> <span class="s1">&#39;.h5&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hf</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">outdict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">hf</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">outdict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: HDF5 export complete&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="save_models"><a class="viewcode-back" href="../../modules.html#hyvr.sim.save_models">[docs]</a><span class="k">def</span> <span class="nf">save_models</span><span class="p">(</span><span class="n">realdir</span><span class="p">,</span> <span class="n">realname</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">flowtrans</span><span class="p">,</span> <span class="n">k_iso</span><span class="p">,</span> <span class="n">ktensors</span><span class="p">,</span> <span class="n">poros</span><span class="p">,</span> <span class="n">anirat</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">azim</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save HYVR outputs to standard modelling codes</span>

<span class="sd">    Parameters:</span>
<span class="sd">        run (dict):			Model run parameters</span>
<span class="sd">        mg:					Mesh grid object class</span>
<span class="sd">        flowtrans (dict):	Flow &amp; transport simulation parameters</span>
<span class="sd">        k_iso:				Horizontal hydraulic conductivity array</span>
<span class="sd">        ktensors:			Array with tensor values of K</span>
<span class="sd">        poros:				Porosity array</span>
<span class="sd">        anirat:				Anistropic ratio ($K_h/K_v$)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Save data outputs as .mf (MODFLOW) or .hgs (HydroGeoSphere)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">realname</span> <span class="o">=</span> <span class="n">realname</span> <span class="o">+</span> <span class="s1">&#39;_hyvr&#39;</span>
    <span class="k">if</span> <span class="s1">&#39;mf&#39;</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
        <span class="c1"># MODFLOW output</span>

        <span class="c1"># Create HGS output folder</span>
        <span class="n">mfdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">realdir</span><span class="p">,</span><span class="s1">&#39;MODFLOW&#39;</span><span class="p">)</span>
        <span class="n">mfname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mfdir</span><span class="p">,</span> <span class="n">realname</span><span class="p">)</span>
        <span class="n">hu</span><span class="o">.</span><span class="n">try_makefolder</span><span class="p">(</span><span class="n">mfdir</span><span class="p">)</span>
        <span class="n">hu</span><span class="o">.</span><span class="n">to_modflow</span><span class="p">(</span><span class="n">mfname</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">flowtrans</span><span class="p">,</span> <span class="n">k_iso</span><span class="p">,</span> <span class="n">anirat</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: MF export complete&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;mf6&#39;</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
        <span class="c1"># MODFLOW 6 output</span>

        <span class="c1"># Create HGS output folder</span>
        <span class="n">mf6dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">realdir</span><span class="p">,</span> <span class="s1">&#39;mf6/hyvr&#39;</span><span class="p">)</span>
        <span class="n">mf6name</span> <span class="o">=</span> <span class="n">realname</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">mf6dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">mf6dir</span><span class="p">)</span>

        <span class="n">hu</span><span class="o">.</span><span class="n">to_mf6</span><span class="p">(</span><span class="n">mf6dir</span><span class="p">,</span> <span class="n">mf6name</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">flowtrans</span><span class="p">,</span> <span class="n">k_iso</span><span class="p">,</span> <span class="n">anirat</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">azim</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: MF6 export complete&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;hgs&#39;</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
        <span class="c1"># HydroGeoSphere output</span>
        <span class="c1"># Create HGS output folder</span>
        <span class="n">hgsdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">realdir</span><span class="p">,</span> <span class="s1">&#39;HGS&#39;</span><span class="p">)</span>
        <span class="n">hu</span><span class="o">.</span><span class="n">try_makefolder</span><span class="p">(</span><span class="n">hgsdir</span><span class="p">)</span>

        <span class="c1"># Write to HGS files</span>
        <span class="n">hu</span><span class="o">.</span><span class="n">to_hgs</span><span class="p">(</span><span class="n">hgsdir</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">flowtrans</span><span class="p">,</span> <span class="n">ktensors</span><span class="p">,</span> <span class="n">poros</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;: HGS export complete&#39;</span><span class="p">)</span></div>


<span class="sd">&quot;&quot;&quot;-------------------------------------------------------------------------------------------------------------- &quot;&quot;&quot;</span>


<span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">Trough generators and utilities</span>
<span class="sd">--------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>


<div class="viewcode-block" id="gen_trough"><a class="viewcode-back" href="../../modules.html#hyvr.sim.gen_trough">[docs]</a><span class="k">def</span> <span class="nf">gen_trough</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">ae</span><span class="p">,</span> <span class="n">ae_arr</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ani</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create trough shapes</span>

<span class="sd">    Parameters:</span>
<span class="sd">        tr (dict): 				Trough parameters</span>
<span class="sd">        mg (grid class): 		Model grid</span>
<span class="sd">        ae (list): 				Architectural element unit details</span>
<span class="sd">        ae_arr (ndarray): 		3D array of system numbers</span>
<span class="sd">        count (int): 			Material number and/or identifier</span>
<span class="sd">        ani (bool):         	Boolean if anisotropy is to be generated</span>

<span class="sd">    Returns:</span>
<span class="sd">        - probs *(numpy array)* - Grid properties</span>
<span class="sd">        - count *(int)* - Material number and/or identifier</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">z3</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">meshup</span><span class="p">()</span>    <span class="c1"># 3-D grid</span>

    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
        <span class="n">hat_arr</span><span class="p">,</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="n">azim</span><span class="p">,</span> <span class="n">dip</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">mat_count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">bg</span><span class="o">=</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;bg&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hat_arr</span><span class="p">,</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="n">fac</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">mat_count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">bg</span><span class="o">=</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;bg&#39;</span><span class="p">],</span> <span class="n">ani</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">ae_arr_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Assign background values</span>
    <span class="n">ae_arr_i</span><span class="p">[</span><span class="n">ae_arr</span> <span class="o">==</span> <span class="n">ae</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ae</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># loop over trough top depths</span>
    <span class="k">if</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;buffer&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tr_bot</span> <span class="o">=</span> <span class="n">ae</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;buffer&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tr_bot</span> <span class="o">=</span> <span class="n">ae</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tr_top</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ae</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">tr_bot</span><span class="p">)</span> <span class="o">+</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;agg&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;te_xyz&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gen_elevations</span> <span class="o">=</span> <span class="p">[</span><span class="n">xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;te_xyz&#39;</span><span class="p">]]</span>
        <span class="n">trough_gen_range</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trough_gen_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;el_z&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span> <span class="o">*</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span><span class="p">)</span>         <span class="c1"># Range of truncated ellipsoid to generate at each elevation</span>
        <span class="n">gen_elevations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tr_bot</span><span class="p">,</span> <span class="n">tr_top</span><span class="p">,</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;agg&#39;</span><span class="p">])</span>               <span class="c1"># aggradation elevations</span>

    <span class="n">tr_xy_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">trough_gen_range</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>                      <span class="c1"># X,Y coordinates of truncated ellipsoid</span>

    <span class="k">for</span> <span class="n">zidx</span><span class="p">,</span> <span class="n">znow</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gen_elevations</span><span class="p">):</span>                                         <span class="c1"># Loop over aggradation elevations</span>
        <span class="k">for</span> <span class="n">eli</span><span class="p">,</span> <span class="n">elno</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trough_gen_range</span><span class="p">):</span>                   <span class="c1"># Loop over troughs</span>
            <span class="c1"># Reneration of trough parameters</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">rand_trough</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">mg</span><span class="o">=</span><span class="n">mg</span><span class="p">,</span> <span class="n">ztr</span><span class="o">=</span><span class="n">znow</span><span class="p">)</span>

            <span class="n">xnow</span> <span class="o">=</span> <span class="n">tr_xy_t</span><span class="p">[</span><span class="n">eli</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ynow</span> <span class="o">=</span> <span class="n">tr_xy_t</span><span class="p">[</span><span class="n">eli</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># center of trough</span>
            <span class="k">if</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;display&#39;</span><span class="p">]:</span>
                <span class="c1"># Place troughs in domain centre for display features</span>
                <span class="n">xnow</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">ynow</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;migrate&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">znow</span> <span class="o">&gt;</span> <span class="n">tr_bot</span><span class="p">:</span>
                <span class="c1"># Migration of troughs</span>
                <span class="n">xnow</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;migrate&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;migrate&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ynow</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;migrate&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;migrate&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;te_xyz&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xnow</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;te_xyz&#39;</span><span class="p">][</span><span class="n">zidx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ynow</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;te_xyz&#39;</span><span class="p">][</span><span class="n">zidx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xnow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span><span class="p">)</span>
                <span class="n">ynow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">mg</span><span class="o">.</span><span class="n">ly</span><span class="o">/-</span><span class="mi">2</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">tr_xy_t</span><span class="p">[</span><span class="n">eli</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnow</span>
            <span class="n">tr_xy_t</span><span class="p">[</span><span class="n">eli</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ynow</span>

            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;paleoflow&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;paleoflow&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>   <span class="c1"># orientation angle of trough (&#39;paleoflow&#39;)</span>
            <span class="n">angnow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;azimuth&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;azimuth&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>      <span class="c1"># orientation of material</span>

            <span class="c1"># Distances to ellipsoid centre</span>
            <span class="n">xd</span> <span class="o">=</span> <span class="n">x3</span> <span class="o">-</span> <span class="n">xnow</span>
            <span class="n">yd</span> <span class="o">=</span> <span class="n">y3</span> <span class="o">-</span> <span class="n">ynow</span>
            <span class="n">zd</span> <span class="o">=</span> <span class="n">z3</span> <span class="o">-</span> <span class="n">znow</span>

            <span class="c1"># Periodic boundary</span>
            <span class="k">if</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;periodic&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">xd</span><span class="p">[</span><span class="n">xd</span> <span class="o">&gt;</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span>
                <span class="n">xd</span><span class="p">[</span><span class="n">xd</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">mg</span><span class="o">.</span><span class="n">lx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span>
                <span class="n">yd</span><span class="p">[</span><span class="n">yd</span> <span class="o">&gt;</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span>
                <span class="n">yd</span><span class="p">[</span><span class="n">yd</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">mg</span><span class="o">.</span><span class="n">ly</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span>
                <span class="n">zd</span><span class="p">[</span><span class="n">zd</span> <span class="o">&gt;</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span>
                <span class="n">zd</span><span class="p">[</span><span class="n">zd</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">mg</span><span class="o">.</span><span class="n">lz</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span>

            <span class="c1"># scaled and rotated distance squared</span>
            <span class="n">select</span><span class="p">,</span> <span class="n">R2</span> <span class="o">=</span> <span class="n">ho</span><span class="o">.</span><span class="n">scale_rotate</span><span class="p">(</span><span class="n">xd</span><span class="p">,</span> <span class="n">yd</span><span class="p">,</span> <span class="n">zd</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">select</span><span class="p">,</span> <span class="n">ae_arr</span> <span class="o">&lt;=</span> <span class="n">ae</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>                <span class="c1"># Restrict selection to AE units equal or below current</span>

            <span class="sd">&quot;&quot;&quot;&quot; Assign internal structure &quot;&quot;&quot;</span>
            <span class="n">tr_struct</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;structure&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">tr_struct</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="n">tr_struct</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;bulb_l&#39;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">select</span><span class="p">)):</span>
                <span class="c1"># Skip section if no grid cells selected</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">select</span><span class="p">):</span>
                <span class="c1"># Skip section if no grid cells selected</span>
                <span class="k">pass</span>

            <span class="k">if</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;hetlev&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ha&#39;</span><span class="p">:</span>
                <span class="c1"># Add &#39;dip layers&#39; into trough</span>
                <span class="n">fac_now</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">])</span>
                <span class="n">fac</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">fac_now</span>
                <span class="n">ha_arr</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">hat_arr</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;ae_id&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">azim</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">angnow</span>    <span class="c1"># Save angle</span>
                    <span class="n">dip</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>                    <span class="c1"># Assignment of architectural elements only</span>
            <span class="k">elif</span> <span class="n">tr_struct</span> <span class="o">==</span> <span class="s1">&#39;bulb&#39;</span><span class="p">:</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Add &#39;bulb&#39; layers into trough</span>
<span class="sd">                    - Dip is derived from the gradient of the truncated ellipsoid boundary</span>
<span class="sd">                    - Azimuth is the angle of the ellipsoid</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># Generate gradient information</span>
                <span class="n">dip_tr</span><span class="p">,</span> <span class="n">azim_tr</span> <span class="o">=</span> <span class="n">ellipsoid_gradient</span><span class="p">(</span><span class="n">xd</span><span class="p">,</span> <span class="n">yd</span><span class="p">,</span> <span class="n">zd</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">tr</span><span class="p">)</span>

                <span class="c1"># Assign generated values to grid cells</span>
                <span class="n">fac_now</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">])</span>
                <span class="n">fac</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">fac_now</span>
                <span class="n">ha_arr</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">hat_arr</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;ae_id&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">dip</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">dip_tr</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
                    <span class="n">azim</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">azim_tr</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">tr_struct</span> <span class="o">==</span> <span class="s1">&#39;bulb_l&#39;</span><span class="p">:</span>

                <span class="c1"># Ellipsoid &#39;c&#39; radii</span>
                <span class="n">c_range</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;bulbset_d&#39;</span><span class="p">])</span>

                <span class="c1"># Iterate over internal truncated ellipsoids</span>
                <span class="k">for</span> <span class="n">c_idx</span><span class="p">,</span> <span class="n">c_now</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c_range</span><span class="p">):</span>
                    <span class="c1"># Get scale factor for ellipsoids -</span>
                    <span class="n">te_scale</span> <span class="o">=</span> <span class="n">c_now</span> <span class="o">/</span> <span class="n">c</span>
                    <span class="n">a_now</span><span class="p">,</span> <span class="n">b_now</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span> <span class="o">*</span> <span class="n">te_scale</span>

                    <span class="c1"># Internal scaled and rotated distance squared</span>
                    <span class="n">bulb_select</span><span class="p">,</span> <span class="n">bulb_R2</span> <span class="o">=</span> <span class="n">ho</span><span class="o">.</span><span class="n">scale_rotate</span><span class="p">(</span><span class="n">xd</span><span class="p">,</span> <span class="n">yd</span><span class="p">,</span> <span class="n">zd</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">a_now</span><span class="p">,</span> <span class="n">b_now</span><span class="p">,</span> <span class="n">c_now</span><span class="p">)</span>

                    <span class="c1"># Generate gradient information</span>
                    <span class="n">dip_bulb</span><span class="p">,</span> <span class="n">azim_bulb</span> <span class="o">=</span> <span class="n">ellipsoid_gradient</span><span class="p">(</span><span class="n">xd</span><span class="p">,</span> <span class="n">yd</span><span class="p">,</span> <span class="n">zd</span><span class="p">,</span> <span class="n">a_now</span><span class="p">,</span> <span class="n">b_now</span><span class="p">,</span> <span class="n">c_now</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">bulb_select</span><span class="p">,</span> <span class="n">tr</span><span class="p">)</span>

                    <span class="c1"># Assign generated values to grid cells</span>
                    <span class="k">if</span> <span class="n">c_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Randomly choose facies</span>
                        <span class="n">fac_now</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Choose next hydrofacies from alternating sets</span>
                        <span class="n">pf_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">])</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fac_now</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>    <span class="c1"># Get facies index</span>
                        <span class="n">fac_now</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;altfacies&#39;</span><span class="p">][</span><span class="n">pf_i</span><span class="p">])</span>                   <span class="c1"># Get next alternating facies</span>

                    <span class="n">fac</span><span class="p">[</span><span class="n">bulb_select</span><span class="p">]</span> <span class="o">=</span> <span class="n">fac_now</span>                                      <span class="c1"># Alternating facies</span>
                    <span class="n">ha_arr</span><span class="p">[</span><span class="n">bulb_select</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                    <span class="n">hat_arr</span><span class="p">[</span><span class="n">bulb_select</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;ae_id&#39;</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                        <span class="n">dip</span><span class="p">[</span><span class="n">bulb_select</span><span class="p">]</span> <span class="o">=</span> <span class="n">dip_bulb</span><span class="p">[</span><span class="n">bulb_select</span><span class="p">]</span>
                        <span class="n">azim</span><span class="p">[</span><span class="n">bulb_select</span><span class="p">]</span> <span class="o">=</span> <span class="n">azim_bulb</span><span class="p">[</span><span class="n">bulb_select</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">tr_struct</span> <span class="o">==</span> <span class="s1">&#39;dip&#39;</span><span class="p">:</span>
                <span class="c1"># Add &#39;dip layers&#39; into trough, with alternating facies</span>
                <span class="n">do</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">av</span> <span class="o">=</span> <span class="n">dip_sets</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">znow</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="n">select</span><span class="p">,</span> <span class="n">azimuth_z</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>

                <span class="c1"># Assign generated values to grid cells</span>
                <span class="n">fac</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">fd</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
                <span class="n">ha_arr</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">hat_arr</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;ae_id&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">dip</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">dv</span>
                    <span class="n">azim</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">av</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Add &#39;dip layers&#39; into trough</span>
                <span class="n">fac</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">])</span>
                <span class="n">ha_arr</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">hat_arr</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;ae_id&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">azim</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">angnow</span>    <span class="c1"># Save angle</span>
                    <span class="n">dip</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">in_lag</span> <span class="o">=</span> <span class="p">(</span><span class="n">znow</span> <span class="o">-</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="n">z3</span>  <span class="c1"># Is grid cell below top of lag surface</span>
                <span class="n">fac</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">select</span><span class="p">,</span> <span class="n">in_lag</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ae_arr_i</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">ae</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ha_arr&#39;</span><span class="p">:</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="s1">&#39;azim&#39;</span><span class="p">:</span> <span class="n">azim</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">:</span> <span class="n">dip</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;ae_arr_i&#39;</span><span class="p">:</span> <span class="n">ae_arr_i</span><span class="p">,</span> <span class="s1">&#39;hat_arr&#39;</span><span class="p">:</span> <span class="n">hat_arr</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ha_arr&#39;</span><span class="p">:</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;ae_arr_i&#39;</span><span class="p">:</span> <span class="n">ae_arr_i</span><span class="p">,</span> <span class="s1">&#39;hat_arr&#39;</span><span class="p">:</span> <span class="n">hat_arr</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">props</span><span class="p">,</span> <span class="n">count</span></div>


<div class="viewcode-block" id="scale_rotate"><a class="viewcode-back" href="../../modules.html#hyvr.sim.scale_rotate">[docs]</a><span class="k">def</span> <span class="nf">scale_rotate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scale and rotate three-dimensional trough</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x, y, z (float):	Spatial coordinates</span>
<span class="sd">        alpha (float):		Rotation angle about the z-axis</span>
<span class="sd">        a, b, c (float):	Axis lengths in x, y, z directions (ellipsoid length, width, depth)</span>

<span class="sd">    Returns:</span>
<span class="sd">        - select - Grid cells within ellipsoid</span>
<span class="sd">        - R2 - Grid of scaled and rotated values</span>

<span class="sd">    &quot;&quot;&quot;</span>




    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">R2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
          <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">+</span>
          <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> \
         <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span>
          <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">+</span>
          <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> \
          <span class="n">z</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">c</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="c1">#  selection of cells</span>
    <span class="n">mask1</span> <span class="o">=</span> <span class="n">R2</span> <span class="o">&lt;=</span> <span class="mi">1</span>
    <span class="n">mask2</span> <span class="o">=</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="mi">0</span>
    <span class="n">select</span> <span class="o">=</span> <span class="n">mask1</span> <span class="o">&amp;</span> <span class="n">mask2</span>

    <span class="k">return</span> <span class="n">select</span><span class="p">,</span> <span class="n">R2</span></div>


<div class="viewcode-block" id="ellipsoid_gradient"><a class="viewcode-back" href="../../modules.html#hyvr.sim.ellipsoid_gradient">[docs]</a><span class="k">def</span> <span class="nf">ellipsoid_gradient</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">tr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate dip and strike values in rotated ellipsoids</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x, y, z:    	Distances to centre of ellipsoid</span>
<span class="sd">        a, b, c:    	Majox/minor axes of ellipsoid</span>
<span class="sd">        alpha:      	Rotation of ellipsoid from mean flow direction</span>

<span class="sd">    Returns:</span>
<span class="sd">        - dip_g - Dipping in 3D</span>
<span class="sd">        - azimuth_g - Azimuth in 3D</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span>  <span class="c1"># Convert alpha to radians</span>

    <span class="c1"># initialize arrays</span>
    <span class="n">dip_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">azimuth_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">idx_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">select</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>     <span class="c1"># Find the &#39;surface cells&#39; of the ellipsoid</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># Return if no values selected</span>
        <span class="k">return</span> <span class="n">dip_g</span><span class="p">,</span> <span class="n">azimuth_g</span>

    <span class="c1"># Calcuate dip and strike for onion</span>
    <span class="n">select_z_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">select</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">idx_z</span><span class="p">])</span>                    <span class="c1"># Indices of grid cells in unit at top of unit</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">select_z_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">select_z_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">idx_z</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">select_z_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">select_z_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">idx_z</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">iz</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">ix</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">+</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">ix</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">+</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span>

    <span class="c1"># Get tangent plane coefficients</span>
    <span class="n">fx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> \
        <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">fy</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ix</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> \
        <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ix</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">fz</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iz</span> <span class="o">/</span> <span class="n">c</span>

    <span class="c1"># Normal vectors of tangent plane, horizontal plane, vertical plane</span>
    <span class="n">n_tan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">fz</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">n_horizontal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>

    <span class="c1"># Calculate the dip at each point</span>
    <span class="n">dip_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">angle</span><span class="p">(</span><span class="n">n_tan</span><span class="p">,</span> <span class="n">n_horizontal</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>

    <span class="c1"># Insert into 2D array</span>
    <span class="n">dip2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">dip2d</span><span class="p">[</span><span class="n">select_z_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">select_z_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dip_vec</span>
    <span class="n">dip2d</span> <span class="o">=</span> <span class="n">dip2d</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="c1"># Apply to 3D arrays</span>
    <span class="n">dip_g</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">dip2d</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
    <span class="n">azimuth_g</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="k">return</span> <span class="n">dip_g</span><span class="p">,</span> <span class="n">azimuth_g</span></div>


<div class="viewcode-block" id="rand_trough"><a class="viewcode-back" href="../../modules.html#hyvr.sim.rand_trough">[docs]</a><span class="k">def</span> <span class="nf">rand_trough</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">mg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ztr</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly generate ellipsoid geometry parameters:</span>

<span class="sd">    Parameters:</span>
<span class="sd">        tr:     	Ellipsoid parameters</span>
<span class="sd">        mg:     	Meshgrid object</span>
<span class="sd">        ztr:    	Elevation of ellipsoid centre point</span>

<span class="sd">    Returns:</span>
<span class="sd">        a, b, c - Length, width and depth of ellipsoid</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ztr</span> <span class="ow">and</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;geo_ztrend&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># zfactor = np.interp(ztr, [mg.oz, mg.oz + mg.lz], [tr[&#39;geo_ztrend&#39;][0], tr[&#39;geo_ztrend&#39;][1]])</span>
        <span class="n">zfactor</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;geo_ztrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">ztr</span> <span class="o">-</span> <span class="n">mg</span><span class="o">.</span><span class="n">oz</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;geo_ztrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">tr</span><span class="p">[</span><span class="s1">&#39;geo_ztrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zfactor</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">zfactor</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">zfactor</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">zfactor</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span></div>

<span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">Extruded parabola generators and utilities</span>
<span class="sd">--------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>


<div class="viewcode-block" id="gen_extpar"><a class="viewcode-back" href="../../modules.html#hyvr.sim.gen_extpar">[docs]</a><span class="k">def</span> <span class="nf">gen_extpar</span><span class="p">(</span><span class="n">ch_par</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">ssm</span><span class="p">,</span> <span class="n">ae_array</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ani</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate extruded parabola geometries:</span>
<span class="sd">        - Flow regime is assumed to be reasonably constant so the major geometry of the extruded parabolas doesn&#39;t change so much</span>
<span class="sd">        - &#39;Migration&#39; of the extruded parabolas according to a shift vector</span>

<span class="sd">    Parameters:</span>
<span class="sd">        ch_par:         Extruded parabola parameters</span>
<span class="sd">        mg:         	Mesh grid object class</span>
<span class="sd">        model (dict):	Model domain parameters</span>
<span class="sd">        ssm (dict):		Strata parameters</span>
<span class="sd">        ae_array:		Array with architectural element unit details</span>
<span class="sd">        count (int): 	Material number and/or identifier</span>
<span class="sd">        ani (bool): 	Boolean if anisotropy is to be generated</span>
<span class="sd">        (z_in:       	starting depth)</span>
<span class="sd">        (thickness:  	Thickness of architectural element)</span>

<span class="sd">    Returns:</span>
<span class="sd">        (tuple): Tuple containing:</span>

<span class="sd">        - probs *(dict)*: Contains data of architectural element units and associated hydrofacies</span>
<span class="sd">            - mat - Material values</span>
<span class="sd">            - azim - Azimuth angles (ani == True)</span>
<span class="sd">            - dip - Dipping angles (ani == True)</span>
<span class="sd">            - fac - Facies values</span>
<span class="sd">            - ae_arr_i - Array with architectural element unit details</span>

<span class="sd">        - count *(int)* - Material number and/or identifier</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Vectors of spatial coordinates</span>
    <span class="n">xvec</span><span class="p">,</span> <span class="n">yvec</span><span class="p">,</span> <span class="n">zvec</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span>
    <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span> <span class="n">yvec</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>          <span class="c1"># 2-D grid</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">z3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>          <span class="c1"># 2-D grid</span>

    <span class="c1"># Initialize storage arrays</span>
    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
        <span class="n">hat_arr</span><span class="p">,</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="n">azim</span><span class="p">,</span> <span class="n">dip</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">bg</span><span class="o">=</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;bg&#39;</span><span class="p">],</span> <span class="n">mat_count</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hat_arr</span><span class="p">,</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="n">fac</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">bg</span><span class="o">=</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;bg&#39;</span><span class="p">],</span> <span class="n">mat_count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">ani</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">ae_arr_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ae_array</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">ae_arr_i</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ssm</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ssm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># start location</span>
    <span class="n">total_extpar</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;channel_no&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;display&#39;</span><span class="p">]:</span>
        <span class="c1"># Place troughs in domain centre for display features</span>
        <span class="n">xstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_extpar</span><span class="p">)</span>
        <span class="n">ystart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">yvec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yvec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">total_extpar</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Randomly place curve starting points</span>
        <span class="n">xstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_extpar</span><span class="p">)</span>
        <span class="n">ystart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">yvec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yvec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">total_extpar</span><span class="p">)</span>

    <span class="c1"># loop over extruded parabola top depths</span>
    <span class="n">ch_bot</span> <span class="o">=</span> <span class="n">ssm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;buffer&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ch_bot</span> <span class="o">+=</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;buffer&#39;</span><span class="p">]</span>

    <span class="n">ch_top</span> <span class="o">=</span> <span class="n">ssm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">ch_dz</span> <span class="o">=</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;agg&#39;</span><span class="p">]</span>
    <span class="n">ch_top</span> <span class="o">+=</span> <span class="n">ch_dz</span>

    <span class="k">for</span> <span class="n">znow</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ch_bot</span><span class="p">,</span> <span class="n">ch_top</span><span class="p">,</span> <span class="n">ch_dz</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39; z = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">znow</span><span class="p">))</span>
        <span class="c1"># Assign linear trend to extruded parabola sizes</span>
        <span class="k">if</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;geo_ztrend&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zfactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">znow</span><span class="p">,</span> <span class="p">[</span><span class="n">mg</span><span class="o">.</span><span class="n">oz</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">oz</span> <span class="o">+</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">],</span> <span class="p">[</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;geo_ztrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;geo_ztrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zfactor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">z_ch_width</span> <span class="o">=</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">zfactor</span>
        <span class="n">z_ch_depth</span> <span class="o">=</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">zfactor</span>

        <span class="k">if</span> <span class="s1">&#39;ch_start&#39;</span> <span class="ow">in</span> <span class="n">ch_par</span><span class="p">:</span>
            <span class="n">cstart</span> <span class="o">=</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;ch_start&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cstart</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Loop over total extruded parabolas per system</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_extpar</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Loop over multiple extruded parabolas at &#39;timestep&#39; &quot;&quot;&quot;</span>
            <span class="n">aha</span> <span class="o">=</span> <span class="n">ferguson_curve</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">],</span>  <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;ds&#39;</span><span class="p">],</span>
                                 <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;eps_factor&#39;</span><span class="p">],</span>
                                 <span class="n">disp</span><span class="o">=</span><span class="n">model</span><span class="p">[</span><span class="s1">&#39;display&#39;</span><span class="p">],</span>
                                 <span class="n">ch_start</span><span class="o">=</span><span class="n">cstart</span><span class="p">)</span>

            <span class="sd">&quot;&quot;&quot; Get flow direction in extruded parabolas for azimuth &quot;&quot;&quot;</span>
            <span class="c1"># For periodicity shift trajectories into model unit cell</span>
            <span class="k">if</span> <span class="n">model</span><span class="p">[</span><span class="s1">&#39;periodic&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">aha</span><span class="p">[</span><span class="n">aha</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">yvec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span>
                <span class="n">aha</span><span class="p">[</span><span class="n">aha</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">yvec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span>

            <span class="c1"># initialize 2-D distance matrix</span>
            <span class="n">D</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>

            <span class="c1"># initialize sum of inverse-distance weights</span>
            <span class="n">sumW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># initialize velocity orientation at this level</span>
            <span class="n">vx_znow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">vy_znow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># loop over all points of trajectory</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aha</span><span class="p">)):</span>
                <span class="c1"># distance to current point</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x2</span> <span class="o">-</span> <span class="n">aha</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">aha</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

                <span class="c1"># smallest distance of entire grid to all points so far</span>
                <span class="n">D</span><span class="p">[</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">]</span>

                <span class="c1"># inverse-distance weight for velocity interpolation</span>
                <span class="n">W</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">20</span>
                <span class="n">W</span><span class="p">[</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">z_ch_width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">z_ch_width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>

                <span class="c1"># velocity interpolation in 2-D</span>
                <span class="n">vx_znow</span> <span class="o">+=</span> <span class="n">aha</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">W</span>
                <span class="n">vy_znow</span> <span class="o">+=</span> <span class="n">aha</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">W</span>
                <span class="n">sumW</span> <span class="o">+=</span> <span class="n">W</span>

            <span class="n">vx_znow</span> <span class="o">/=</span> <span class="n">sumW</span>
            <span class="n">vy_znow</span> <span class="o">/=</span> <span class="n">sumW</span>

            <span class="c1"># Assign facies sets with dip values</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">do</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">av</span> <span class="o">=</span> <span class="n">dip_sets</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">ch_par</span><span class="p">,</span> <span class="n">znow</span><span class="p">,</span> <span class="n">curve</span><span class="o">=</span><span class="p">[</span><span class="n">aha</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">aha</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vx_znow</span><span class="p">,</span> <span class="n">vy_znow</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">do</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span> <span class="o">+</span> <span class="n">count</span>
                <span class="n">fd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">]))</span>
                <span class="n">dv</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">av</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>

            <span class="sd">&quot;&quot;&quot; Copy results into 3-D field &quot;&quot;&quot;</span>
            <span class="c1"># Iterate over all nodes below current top elevation</span>
            <span class="n">d_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">znow</span> <span class="o">-</span> <span class="n">z_ch_depth</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">znow</span><span class="p">)))</span>      <span class="c1"># Depth range</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>        <span class="c1"># Only compute if extruded parabola depth range is finite</span>

                <span class="c1"># Get mask arrays for each condition</span>
                <span class="n">in_extpar</span> <span class="o">=</span> <span class="n">D</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">z_ch_width</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">-</span> <span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">znow</span><span class="p">)</span> <span class="o">-</span> <span class="n">z3</span><span class="p">)</span> <span class="o">*</span> <span class="n">mg</span><span class="o">.</span><span class="n">dz</span> <span class="o">*</span> <span class="n">z_ch_width</span> <span class="o">/</span> <span class="p">(</span><span class="n">z_ch_depth</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>     <span class="c1"># is grid cell in extruded parabola</span>
                <span class="n">finite_v</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vx_znow</span><span class="p">)</span>            <span class="c1"># Only assign if velocity is finite</span>
                <span class="n">below_top</span> <span class="o">=</span> <span class="n">ae_array</span> <span class="o">&lt;=</span> <span class="n">ssm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>          <span class="c1"># Don&#39;t assign values to locations higher than top contact surface</span>
                <span class="n">chan_mask</span> <span class="o">=</span> <span class="n">in_extpar</span> <span class="o">*</span> <span class="n">finite_v</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">below_top</span>
                <span class="k">if</span> <span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">znow</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">z3</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
                    <span class="c1"># Set mask above top of extruded parabola to False</span>
                    <span class="n">chan_mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">znow</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># Assign properties</span>
                <span class="n">fac</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fd</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span>
                <span class="n">ha_arr</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">hat_arr</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;ae_id&#39;</span><span class="p">]</span>
                <span class="n">ae_arr_i</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">in_lag</span> <span class="o">=</span> <span class="p">(</span><span class="n">znow</span> <span class="o">-</span> <span class="n">z_ch_depth</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="n">z3</span> <span class="o">*</span> <span class="n">mg</span><span class="o">.</span><span class="n">dz</span>   <span class="c1"># Is grid cell in extruded parabola</span>
                    <span class="n">fac</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">in_extpar</span><span class="p">,</span> <span class="n">in_lag</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="c1"># calcuate azimuth, to 1 degree</span>
                    <span class="n">azim2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vx_znow</span><span class="p">,</span> <span class="n">vy_znow</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="n">azim3d</span> <span class="o">=</span> <span class="n">azim2d</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>
                    <span class="n">azim</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">azim3d</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span>
                    <span class="n">dip</span><span class="p">[</span><span class="n">chan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">dv</span>

                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Shift starting values with migration vector from parameter file</span>
        <span class="k">if</span> <span class="s1">&#39;mig&#39;</span> <span class="ow">in</span> <span class="n">ch_par</span><span class="p">:</span>
            <span class="n">xstart</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;mig&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;mig&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ystart</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;mig&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;mig&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ha_arr&#39;</span><span class="p">:</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="s1">&#39;azim&#39;</span><span class="p">:</span> <span class="n">azim</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">:</span> <span class="n">dip</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;ae_arr_i&#39;</span><span class="p">:</span> <span class="n">ae_arr_i</span><span class="p">,</span> <span class="s1">&#39;hat_arr&#39;</span><span class="p">:</span> <span class="n">hat_arr</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ha_arr&#39;</span><span class="p">:</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;ae_arr_i&#39;</span><span class="p">:</span> <span class="n">ae_arr_i</span><span class="p">,</span> <span class="s1">&#39;hat_arr&#39;</span><span class="p">:</span> <span class="n">hat_arr</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">props</span><span class="p">,</span> <span class="n">count</span></div>


<div class="viewcode-block" id="ferguson_curve"><a class="viewcode-back" href="../../modules.html#hyvr.sim.ferguson_curve">[docs]</a><span class="k">def</span> <span class="nf">ferguson_curve</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">eps_factor</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ch_start</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate extruded parabola centrelines using the Ferguson (1976) disturbed meander model</span>
<span class="sd">    Implementation of AR2 autoregressive model</span>
<span class="sd">    http://onlinelibrary.wiley.com/doi/10.1002/esp.3290010403/full</span>

<span class="sd">    Parameters:</span>
<span class="sd">        mg (object class):			Mesh grid object class</span>
<span class="sd">        h (float):					Height</span>
<span class="sd">        k (float):					Wave number</span>
<span class="sd">        ds(float):					Curve distance for calculations</span>
<span class="sd">        eps_factor (float):			Random background noise</span>
<span class="sd">        dist (float): 		        Distance to generate curves - defaults to mg.lx</span>
<span class="sd">        disp (bool): 		        Creating display extruded parabola - extruded parabola begins at (0,0)</span>
<span class="sd">        ch_start (tuple):           Starting location of channel (x,y coordinates)</span>

<span class="sd">    Returns:</span>
<span class="sd">        outputs (float array):		Simulated extruded parabola centerlines: storage array containing values for x coordinate, y coordinate, vx and vy</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Parameters</span>
    <span class="n">ds</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">10</span>
    <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="n">dist</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span><span class="o">*</span><span class="mi">100</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span>

    <span class="c1"># Centreline starting point</span>
    <span class="n">xp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">yp</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Calculate curve directions</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">ferguson_theta</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">eps_factor</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

    <span class="c1"># Interpolate curve direction over interval of interest</span>
    <span class="n">s_interp</span><span class="p">,</span> <span class="n">th_interp</span> <span class="o">=</span> <span class="n">curve_interp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>

    <span class="c1"># Storage array</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">th_interp</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">th_idx</span><span class="p">,</span> <span class="n">th_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">th_interp</span><span class="p">):</span>
        <span class="n">vx</span> <span class="o">=</span> <span class="n">ds</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">th_i</span><span class="p">)</span>
        <span class="n">vy</span> <span class="o">=</span> <span class="n">ds</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">th_i</span><span class="p">)</span>
        <span class="n">xp</span> <span class="o">+=</span> <span class="n">vx</span>
        <span class="n">yp</span> <span class="o">+=</span> <span class="n">vy</span>

        <span class="c1"># Assign to storage array</span>
        <span class="n">outputs</span><span class="p">[</span><span class="n">th_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xp</span>       <span class="c1"># x coordinate</span>
        <span class="n">outputs</span><span class="p">[</span><span class="n">th_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yp</span>       <span class="c1"># y coordinate</span>
        <span class="n">outputs</span><span class="p">[</span><span class="n">th_idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vx</span>       <span class="c1"># vx</span>
        <span class="n">outputs</span><span class="p">[</span><span class="n">th_idx</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">vy</span>       <span class="c1"># vy</span>

    <span class="c1"># Rotate meanders into mean flow direction</span>
    <span class="n">mean_th</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">th_interp</span><span class="p">)</span>
    <span class="n">rotMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">mean_th</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">mean_th</span><span class="p">)],</span>
                          <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">mean_th</span><span class="p">),</span>  <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">mean_th</span><span class="p">)]])</span>
    <span class="n">roro</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotMatrix</span><span class="p">,</span> <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

    <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotMatrix</span><span class="p">,</span> <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="c1"># Move starting location in x-direction</span>
    <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">roro</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">mg</span><span class="o">.</span><span class="n">lx</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">roro</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="c1"># Remove values before model domain</span>
    <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">indomain</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">mg</span><span class="o">.</span><span class="n">ox</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indomain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">outputs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">mg</span><span class="o">.</span><span class="n">ox</span><span class="p">,</span> <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span><span class="p">)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="n">indomain</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ch_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ch_start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Make sure streamlines begin within domain with respect to y</span>
    <span class="n">yout</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span><span class="o">/</span><span class="mi">4</span> <span class="ow">or</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span><span class="o">/</span><span class="mi">4</span>
    <span class="k">if</span> <span class="n">disp</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">starty</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">yout</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">starty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">mg</span><span class="o">.</span><span class="n">ly</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ly</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">starty</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">starty</span>

    <span class="k">return</span> <span class="n">outputs</span></div>


<div class="viewcode-block" id="ferguson_theta"><a class="viewcode-back" href="../../modules.html#hyvr.sim.ferguson_theta">[docs]</a><span class="k">def</span> <span class="nf">ferguson_theta</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">eps_factor</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate curve direction angle</span>

<span class="sd">    Parameters:</span>
<span class="sd">        s:				    Steps within generated curve distance</span>
<span class="sd">        eps_factor:		    Random background noise</span>
<span class="sd">        k:				    Wave number</span>
<span class="sd">        h:				    Height</span>

<span class="sd">    Returns:</span>
<span class="sd">        th_store *(array)* - Curve direction angle</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Storage arrays</span>
    <span class="n">th_store</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">idex</span><span class="p">,</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">idex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">idex</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">th_store</span><span class="p">[</span><span class="n">idex</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span><span class="o">*</span><span class="n">eps_factor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">th_store</span><span class="p">[</span><span class="n">idex</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">th_store</span><span class="p">[</span><span class="n">idex</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">eps_factor</span>

        <span class="n">th_store</span><span class="p">[</span><span class="n">idex</span><span class="p">]</span> <span class="o">=</span> <span class="n">thetaAR2</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">th_store</span></div>


<div class="viewcode-block" id="thetaAR2"><a class="viewcode-back" href="../../modules.html#hyvr.sim.thetaAR2">[docs]</a><span class="k">def</span> <span class="nf">thetaAR2</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of AR2 autoregressive model (Ferguson, 1976, Eq.15)</span>
<span class="sd">    http://onlinelibrary.wiley.com/doi/10.1002/esp.3290010403/full</span>

<span class="sd">    Parameters:</span>
<span class="sd">        t1: 	theta(i-1)</span>
<span class="sd">        t2: 	theta(i-2)</span>
<span class="sd">        k:		Wavenumber</span>
<span class="sd">        h:		Height</span>
<span class="sd">        eps:	Random background noise</span>

<span class="sd">    Returns:</span>
<span class="sd">        2nd-order autoregression (AR2)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="n">h</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eps</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">t1</span> <span class="o">+</span> <span class="n">b2</span><span class="o">*</span><span class="n">t2</span></div>


<span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">Sheet generators and utilities</span>
<span class="sd">--------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>


<div class="viewcode-block" id="gen_sheet"><a class="viewcode-back" href="../../modules.html#hyvr.sim.gen_sheet">[docs]</a><span class="k">def</span> <span class="nf">gen_sheet</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">ae_i</span><span class="p">,</span> <span class="n">ae_array</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ani</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate gravel sheet with internal heterogeneity</span>

<span class="sd">    Parameters:</span>
<span class="sd">        sh:         	Sheet parameters</span>
<span class="sd">        mg:         	Model grid class</span>
<span class="sd">        ae_i:       	Architectural element lookup details [system number, z_bottom, z_top, architectural element, geometry]</span>
<span class="sd">        ae_array:   	Architectural element array</span>
<span class="sd">        count (int): 	Material number and/or identifier</span>
<span class="sd">        ani (bool):		Boolean if anisotropy is to be generated</span>

<span class="sd">    Returns:</span>
<span class="sd">        - probs *(dict)* - Contains data of architectural element units and associated hydrofacies (e.g. values of azimuth, material, dipping, etc.)</span>
<span class="sd">        - count *(int)* - Material number and/or identifier</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize storage arrays</span>
    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
        <span class="n">hat_arr</span><span class="p">,</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="n">azim</span><span class="p">,</span> <span class="n">dip</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hat_arr</span><span class="p">,</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="n">fac</span> <span class="o">=</span> <span class="n">save_arrays</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">ani</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">hat_arr</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;ae_id&#39;</span><span class="p">]</span>

    <span class="c1"># Massive bedding -----------------------------------</span>
    <span class="k">if</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;lens_thickness&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Generate dip</span>
        <span class="k">if</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">do</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">av</span> <span class="o">=</span> <span class="n">dip_sets</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">sh</span><span class="p">,</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>               <span class="c1"># Generate facies sets</span>
                <span class="n">fac</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">fd</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">ha_arr</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">do</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">do</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">azim</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">dip</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dv</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fac</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ha_arr</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span>  <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">azim</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;azimuth&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;azimuth&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">dip</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;azimuth&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;azimuth&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fac</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ha_arr</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span>  <span class="n">count</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                <span class="n">azim</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;azimuth&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;azimuth&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">dip</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No dip</span>
            <span class="n">ha_arr</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">count</span>
            <span class="n">fac</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                <span class="n">azim</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">dip</span><span class="p">[</span><span class="n">ae_array</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Create lenses over depths ------------------------------</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Assign lens thickness for system</span>
        <span class="k">if</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;geo_ztrend&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zfactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ae_i</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]),</span> <span class="p">[</span><span class="n">mg</span><span class="o">.</span><span class="n">oz</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">oz</span> <span class="o">+</span> <span class="n">mg</span><span class="o">.</span><span class="n">lz</span><span class="p">],</span> <span class="p">[</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;geo_ztrend&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;geo_ztrend&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">z_lens_thick</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;lens_thickness&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">zfactor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z_lens_thick</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;lens_thickness&#39;</span><span class="p">]</span>
        <span class="n">z_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ae_i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">z_lens_thick</span><span class="p">)</span>          <span class="c1"># Buffer added to top elevation to avoid non-assignment</span>

        <span class="c1"># Loop over lenses</span>
        <span class="k">for</span> <span class="n">znow</span> <span class="ow">in</span> <span class="n">z_lens</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">z_bottom</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">znow</span><span class="p">)</span>
            <span class="n">z_top</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">mg</span><span class="o">.</span><span class="n">idx_z</span><span class="p">(</span><span class="n">znow</span> <span class="o">+</span> <span class="n">sh</span><span class="p">[</span><span class="s1">&#39;lens_thickness&#39;</span><span class="p">]),</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">)</span>
            <span class="n">z_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">z_bottom</span><span class="p">,</span> <span class="n">z_top</span><span class="p">)</span>

            <span class="c1"># Generate dip</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">do</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">av</span> <span class="o">=</span> <span class="n">dip_sets</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">sh</span><span class="p">,</span> <span class="n">znow</span><span class="p">)</span>               <span class="c1"># Generate facies sets</span>

                <span class="c1"># Iterate over all nodes - Brute force approach :(</span>
                <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">ae_array</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;multi_index&#39;</span><span class="p">])</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">z_range</span> <span class="ow">and</span> <span class="n">ae_array</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">==</span> <span class="n">ae_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">fac</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">fd</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span>
                        <span class="n">ha_arr</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">do</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span>

                    <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>

                <span class="n">count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">do</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">azim</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">z_range</span><span class="p">]</span> <span class="o">=</span> <span class="n">av</span>
                    <span class="n">dip</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">z_range</span><span class="p">]</span> <span class="o">=</span> <span class="n">dv</span>   <span class="c1"># Assign facies sets to storage arrays</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fac</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">z_range</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">])</span>
                <span class="n">ha_arr</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">z_range</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
                    <span class="n">azim</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">z_range</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">dip</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">z_range</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ha_arr&#39;</span><span class="p">:</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="s1">&#39;azim&#39;</span><span class="p">:</span> <span class="n">azim</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">:</span> <span class="n">dip</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;hat_arr&#39;</span><span class="p">:</span> <span class="n">hat_arr</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ha_arr&#39;</span><span class="p">:</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">:</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;hat_arr&#39;</span><span class="p">:</span> <span class="n">hat_arr</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">props</span><span class="p">,</span> <span class="n">count</span></div>


<div class="viewcode-block" id="dip_sets"><a class="viewcode-back" href="../../modules.html#hyvr.sim.dip_sets">[docs]</a><span class="k">def</span> <span class="nf">dip_sets</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">aep</span><span class="p">,</span> <span class="n">znow</span><span class="p">,</span> <span class="n">curve</span><span class="o">=</span><span class="p">[],</span> <span class="n">select</span><span class="o">=</span><span class="p">[],</span> <span class="n">azimuth_z</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate dip angles and assign to the dip matrix</span>

<span class="sd">    Parameters:</span>
<span class="sd">        mg:         Mesh grid object class</span>
<span class="sd">        aep:        Architectural element parameters (dict)</span>
<span class="sd">        cruve:    Tuple of x,y coordinates of extruded parabola (omitted for linear flows)</span>
<span class="sd">                        - x, y coordinates of extruded parabola</span>
<span class="sd">                        - vx, vy of extruded parabola flow</span>
<span class="sd">        select:     Model grid nodes to assign</span>

<span class="sd">    Returns:</span>
<span class="sd">        - dip_out - Array of assigned dip values</span>
<span class="sd">        - fac_out - Array of assigned hydrofacies</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Vectors of spatial coordinates of grid</span>
    <span class="c1"># xgvec, ygvec, zgvec = mg.vec()                              # Grid vectors</span>
    <span class="n">xtemp</span><span class="p">,</span> <span class="n">ytemp</span><span class="p">,</span> <span class="n">ztemp</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">meshup</span><span class="p">()</span>      <span class="c1"># 3-D grid</span>

    <span class="c1"># Define series of points for plane equations</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curve</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Interpolate points along the extruded parabola trajectory</span>
        <span class="n">x_dip</span><span class="p">,</span> <span class="n">y_dip</span> <span class="o">=</span> <span class="n">curve_interp</span><span class="p">(</span><span class="n">curve</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">curve</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">aep</span><span class="p">[</span><span class="s1">&#39;dipset_d&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">aep</span><span class="p">[</span><span class="s1">&#39;azimuth&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">azimuth_z</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;azimuth&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">aep</span><span class="p">[</span><span class="s1">&#39;azimuth&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">xst</span> <span class="o">=</span> <span class="o">-</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;dipset_d&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">20</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">aep</span><span class="p">[</span><span class="s1">&#39;dipset_d&#39;</span><span class="p">])</span>        <span class="c1"># Starting x-coordinate of plane points</span>
        <span class="n">xend</span> <span class="o">=</span> <span class="n">mg</span><span class="o">.</span><span class="n">lx</span> <span class="o">*</span> <span class="mf">1.5</span> <span class="o">-</span> <span class="n">xst</span>                                                  <span class="c1"># Final x-coordinate of plane points</span>

        <span class="c1"># Get coordinate differences</span>
        <span class="n">lamb_dip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xst</span><span class="p">,</span> <span class="n">xend</span><span class="p">,</span> <span class="n">aep</span><span class="p">[</span><span class="s1">&#39;dipset_d&#39;</span><span class="p">])</span>
        <span class="n">xpvec</span> <span class="o">=</span> <span class="n">lamb_dip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">azimuth_z</span><span class="p">))</span>
        <span class="n">ypvec</span> <span class="o">=</span> <span class="n">lamb_dip</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">azimuth_z</span><span class="p">))</span>

        <span class="c1"># Calculate coordinates of dip points</span>
        <span class="n">x_dip</span> <span class="o">=</span> <span class="n">xst</span> <span class="o">+</span> <span class="n">xpvec</span>
        <span class="n">y_dip</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">ypvec</span>

    <span class="c1"># Calculate normal vector components in x/y by getting the difference between points</span>
    <span class="n">p_setlamb</span> <span class="o">=</span> <span class="p">(</span><span class="n">xpvec</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ypvec</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="c1"># Define normal vector (This might change if the plane is angled (i.e. extruded parabola settings)</span>
    <span class="n">dip_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">aep</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">dip_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xpvec</span><span class="p">))</span> <span class="o">*</span> <span class="n">dip_z</span>
    <span class="n">dip_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xpvec</span><span class="p">,</span> <span class="n">ypvec</span><span class="p">,</span> <span class="n">p_setlamb</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">90</span> <span class="o">-</span> <span class="n">dip_set</span><span class="p">))])</span> <span class="c1">#np.array((1, 0, np.tan(np.deg2rad(90 - aep[&#39;dip&#39;][1]))))</span>

    <span class="n">set_no</span> <span class="o">=</span> <span class="n">planepoint</span><span class="p">(</span><span class="n">dip_norm</span><span class="p">,</span> <span class="n">x_dip</span><span class="p">,</span> <span class="n">y_dip</span><span class="p">,</span> <span class="n">znow</span><span class="p">,</span> <span class="n">xtemp</span><span class="p">,</span> <span class="n">ytemp</span><span class="p">,</span> <span class="n">ztemp</span><span class="p">,</span> <span class="n">select</span><span class="p">)</span>
    <span class="c1"># Re-index set_no, starting from 1 to work with &#39;count&#39;</span>
    <span class="n">set_no</span> <span class="o">=</span> <span class="n">ho</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">set_no</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="sd">&quot;&quot;&quot; Assign hydrofacies &quot;&quot;&quot;</span>
    <span class="c1"># Initialise hydrofacies array</span>
    <span class="n">fac_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mg</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">mg</span><span class="o">.</span><span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">aep</span><span class="p">[</span><span class="s1">&#39;altfacies&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Alternating hydrofacies</span>
        <span class="n">ae_fac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">fac_now</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ae_fac</span><span class="p">)</span>       <span class="c1"># Initialise previous facies</span>
        <span class="k">for</span> <span class="n">idi</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">set_no</span><span class="p">):</span>
            <span class="n">pf_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">fac_now</span> <span class="o">==</span> <span class="n">ae_fac</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>                                         <span class="c1"># Get previous facies index</span>
            <span class="n">fac_now</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;altfacies&#39;</span><span class="p">][</span><span class="n">pf_i</span><span class="p">])</span>  <span class="c1"># Get next alternating facies</span>
            <span class="n">fac_set</span><span class="p">[</span><span class="n">set_no</span> <span class="o">==</span> <span class="n">idi</span><span class="p">]</span> <span class="o">=</span> <span class="n">fac_now</span>                                                    <span class="c1"># Set previous facies</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">facies</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">]):</span>      <span class="c1"># Cycle over hydrofacies in element</span>
            <span class="n">fac_set</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">set_no</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">facies</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Random assignment of hydrofacies</span>
        <span class="k">for</span> <span class="n">idi</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">set_no</span><span class="p">):</span>
            <span class="n">fac_set</span><span class="p">[</span><span class="n">set_no</span> <span class="o">==</span> <span class="n">idi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">aep</span><span class="p">[</span><span class="s1">&#39;facies&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">set_no</span><span class="p">,</span> <span class="n">fac_set</span><span class="p">,</span> <span class="n">dip_z</span><span class="p">,</span> <span class="n">azimuth_z</span></div>


<div class="viewcode-block" id="curve_interp"><a class="viewcode-back" href="../../modules.html#hyvr.sim.curve_interp">[docs]</a><span class="k">def</span> <span class="nf">curve_interp</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">spacing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate evenly spaced points along a curve. This code is based on code in an answer posted by &#39;Unutbu&#39; on</span>
<span class="sd">    http://stackoverflow.com/questions/19117660/how-to-generate-equispaced-interpolating-values (retrieved 17/04/2017)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        xc:			x coordinates of curve</span>
<span class="sd">        yc:			y coordinates of curve</span>
<span class="sd">        spacing:	Spacing between points</span>

<span class="sd">    Returns:</span>
<span class="sd">        - xn - x coordinates of interpolated points</span>
<span class="sd">        - yn - y coordinates of interpolated points</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">xc</span><span class="p">),</span> <span class="n">spacing</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="n">xc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xc</span><span class="p">)),</span> <span class="n">xc</span><span class="p">)</span>
    <span class="n">yc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">yc</span><span class="p">)),</span> <span class="n">yc</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="n">spacing</span>
    <span class="n">ic</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">ic</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">xc</span><span class="p">):</span>
        <span class="n">total_dist</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ic</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xc</span><span class="p">)):</span>
            <span class="n">total_dist</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">xc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">xc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">yc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">yc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">total_dist</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">xn</span> <span class="o">=</span> <span class="n">xc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">yn</span> <span class="o">=</span> <span class="n">yc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="c1"># fig, ax = plt.subplots()</span>
    <span class="c1"># ax.plot(xc, yc, &#39;-&#39;)</span>
    <span class="c1"># ax.scatter(xn, yn)</span>
    <span class="c1"># ax.set_aspect(&#39;equal&#39;)</span>
    <span class="c1"># plt.show()</span>

    <span class="k">return</span> <span class="n">xn</span><span class="p">,</span> <span class="n">yn</span></div>


<div class="viewcode-block" id="dip_rotate"><a class="viewcode-back" href="../../modules.html#hyvr.sim.dip_rotate">[docs]</a><span class="k">def</span> <span class="nf">dip_rotate</span><span class="p">(</span><span class="n">azimuth_in</span><span class="p">,</span> <span class="n">dip_in</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate dip angle based on azimuth</span>
<span class="sd">    Note that inputs and outputs are in degrees</span>

<span class="sd">    Parameters:</span>
<span class="sd">        azimuth_in:		Azimuth input angle</span>
<span class="sd">        dip_in:			Dipping input angle</span>

<span class="sd">    Returns:</span>
<span class="sd">        dip_out - Azimuth output angle</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">azimuth_in</span> <span class="o">=</span> <span class="n">azimuth_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
    <span class="n">dip_in</span> <span class="o">=</span> <span class="n">dip_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
    <span class="n">dip_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">azimuth_in</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">azimuth_in</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">dip_in</span><span class="p">))</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">azimuth_in</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">azimuth_in</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">dip_in</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">dip_out</span></div>



<span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">Assignment of hydraulic properties</span>
<span class="sd">--------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">General functions</span>
<span class="sd">--------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>


<div class="viewcode-block" id="save_arrays"><a class="viewcode-back" href="../../modules.html#hyvr.sim.save_arrays">[docs]</a><span class="k">def</span> <span class="nf">save_arrays</span><span class="p">(</span><span class="n">arr_size</span><span class="p">,</span> <span class="n">bg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mat_count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ani</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate arrays for material properties storage</span>

<span class="sd">    Parameters:</span>
<span class="sd">        arr_size:       Size of array</span>
<span class="sd">        bg:             List of background values for each array</span>
<span class="sd">        ani (bool):	    Boolean if anisotropy is to be generated</span>

<span class="sd">    Returns:</span>
<span class="sd">        - ha_arr - Material values</span>
<span class="sd">        - fac - Facies values</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">bg</span><span class="p">:</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>

    <span class="n">hat_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">arr_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>                 <span class="c1"># initialize architectural elements</span>
    <span class="n">ha_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">arr_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">*</span> <span class="n">mat_count</span>             <span class="c1"># initialize material</span>
    <span class="n">fac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">arr_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">bg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>            <span class="c1"># initialize hydrofacies</span>

    <span class="k">if</span> <span class="n">ani</span><span class="p">:</span>
        <span class="n">azim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">arr_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">bg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>     <span class="c1"># initialize azimuth angle</span>
        <span class="n">dip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">arr_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">bg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>       <span class="c1"># initialize dip angle</span>
        <span class="k">return</span> <span class="n">hat_arr</span><span class="p">,</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="n">azim</span><span class="p">,</span> <span class="n">dip</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hat_arr</span><span class="p">,</span> <span class="n">ha_arr</span><span class="p">,</span> <span class="n">fac</span></div>


<div class="viewcode-block" id="prob_choose"><a class="viewcode-back" href="../../modules.html#hyvr.sim.prob_choose">[docs]</a><span class="k">def</span> <span class="nf">prob_choose</span><span class="p">(</span><span class="n">choices</span><span class="p">,</span> <span class="n">probs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get random values of an architectural element</span>

<span class="sd">    Parameters:</span>
<span class="sd">        choices:	Fixed number of choices</span>
<span class="sd">        probs: 		Contains data of architectural element units and associated hydrofacies</span>

<span class="sd">    Returns:</span>
<span class="sd">        choice *(int)* - Random value of architectural elements</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ae_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">chi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">choices</span><span class="p">)):</span>
        <span class="n">ae_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">choices</span><span class="p">[</span><span class="n">chi</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="n">chi</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">choice</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ae_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">choice</span></div>


<div class="viewcode-block" id="angle"><a class="viewcode-back" href="../../modules.html#hyvr.sim.angle">[docs]</a><span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return angle between two vectors in [°]</span>

<span class="sd">    Parameters:</span>
<span class="sd">        v1:	Vector 1</span>
<span class="sd">        v2:	Vector 2</span>

<span class="sd">    Returns:</span>
<span class="sd">        angle value *(float)* - Angle between v1 and v2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))))</span></div>


<div class="viewcode-block" id="channel_checker"><a class="viewcode-back" href="../../modules.html#hyvr.sim.channel_checker">[docs]</a><span class="k">def</span> <span class="nf">channel_checker</span><span class="p">(</span><span class="n">param_file</span><span class="p">,</span> <span class="n">ae_name</span><span class="p">,</span> <span class="n">no_extpar</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    extruded parabola checker function for quickly assessing the shape of extruded parabola inputs</span>

<span class="sd">    Parameters:</span>
<span class="sd">        param_file (str): 		Parameter file location</span>
<span class="sd">        ae_name (str):			Name of architectural element</span>
<span class="sd">        no_extpar (float):	Number of extruded parabolas</span>
<span class="sd">        dist (float): 			Distance to generate extruded parabolas - defaults to mg.lx</span>

<span class="sd">    Returns:</span>
<span class="sd">        Plots showing shape of Ferguson extruded parabolas</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">run</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">strata</span><span class="p">,</span> <span class="n">hydraulics</span><span class="p">,</span> <span class="n">flowtrans</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">mg</span> <span class="o">=</span> <span class="n">hu</span><span class="o">.</span><span class="n">model_setup</span><span class="p">(</span><span class="n">param_file</span><span class="p">)</span>
    <span class="n">ch_par</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">ae_name</span><span class="p">]</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no_extpar</span><span class="p">):</span>
        <span class="n">chs</span> <span class="o">=</span> <span class="n">ferguson_curve</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">],</span>  <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;ds&#39;</span><span class="p">],</span> <span class="n">ch_par</span><span class="p">[</span><span class="s1">&#39;eps_factor&#39;</span><span class="p">],</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">chs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">chs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="s1">&#39;datalim&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="planepoint"><a class="viewcode-back" href="../../modules.html#hyvr.sim.planepoint">[docs]</a><span class="k">def</span> <span class="nf">planepoint</span><span class="p">(</span><span class="n">dip_norm</span><span class="p">,</span> <span class="n">x_dip</span><span class="p">,</span> <span class="n">y_dip</span><span class="p">,</span> <span class="n">znow</span><span class="p">,</span> <span class="n">xtemp</span><span class="p">,</span> <span class="n">ytemp</span><span class="p">,</span> <span class="n">ztemp</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute number of planes</span>

<span class="sd">    Parameters:</span>
<span class="sd">        dip_norm:</span>
<span class="sd">        x_dip:			X coordinates of points on dip planes</span>
<span class="sd">        y_dip:			Y coordinates of points on dip planes</span>
<span class="sd">        znow:			Current coordinates of Z, needed to compute Z coordinates of points on dip planes</span>
<span class="sd">        xtemp:			X dimension of model grid nodes</span>
<span class="sd">        ytemp:			Y dimension of model grid nodes</span>
<span class="sd">        ztemp:			Z dimension of model grid nodes</span>
<span class="sd">        select:         Model grid nodes to consider</span>

<span class="sd">    Returns:</span>
<span class="sd">        set_no - Number of planes with selected model grid nodes</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get closest plane to points</span>
    <span class="n">n_sets</span> <span class="o">=</span> <span class="n">dip_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>                   <span class="c1"># Number of planes</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">xtemp</span><span class="o">.</span><span class="n">shape</span>                       <span class="c1"># Get number of model cells</span>
    <span class="n">set_no</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>  <span class="c1"># Initialise set number array</span>
    <span class="n">z_dip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x_dip</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">znow</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">xtemp</span><span class="p">[</span><span class="n">select</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">ytemp</span><span class="p">[</span><span class="n">select</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">ztemp</span><span class="p">[</span><span class="n">select</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span>      <span class="c1"># Cartesian coordinates of model grid nodes</span>
    <span class="n">plp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x_dip</span><span class="p">,</span> <span class="n">y_dip</span><span class="p">,</span> <span class="n">z_dip</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>                                     <span class="c1"># Cartesian coordinates of points on dip planes</span>
    <span class="n">pd</span> <span class="o">=</span> <span class="n">plp</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="o">.</span><span class="n">T</span>                                                <span class="c1"># subtract grid nodes from plane points</span>

    <span class="n">select_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>                                               <span class="c1"># Get indices of selected model nodes</span>

    <span class="c1"># Loop over set planes</span>
    <span class="k">for</span> <span class="n">iset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sets</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">iset</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pd_1</span> <span class="o">=</span> <span class="n">pd_2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">abc_1</span> <span class="o">=</span> <span class="n">dip_norm</span><span class="p">[:,</span> <span class="n">iset</span><span class="p">]</span>                                                           <span class="c1"># Plane normal equation</span>
            <span class="n">pd_1</span> <span class="o">=</span> <span class="n">abc_1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="n">iset</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">abc_1</span> <span class="o">*</span> <span class="n">abc_1</span><span class="p">))</span>          <span class="c1"># Distance to plane</span>
        <span class="n">pd1_c1</span> <span class="o">=</span> <span class="n">pd_1</span> <span class="o">&lt;=</span> <span class="mi">0</span>                                                                  <span class="c1"># pd_1 meeting condition 1</span>
        <span class="n">pd1_c1_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pd1_c1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">iset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">set_no</span><span class="p">[</span><span class="n">select_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">pd1_c1_idx</span><span class="p">],</span> <span class="n">select_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">pd1_c1_idx</span><span class="p">],</span> <span class="n">select_idx</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">pd1_c1_idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">iset</span><span class="o">+</span><span class="mi">1</span>
        <span class="c1"># elif iset == n_sets: # this never happens</span>
        <span class="c1">#     pd1_c2_idx = np.where(pd_1 &gt; 0)                     # index of pd_2 meeting condition 1</span>
        <span class="c1">#     set_no[select_idx[0][pd1_c2_idx], select_idx[1][pd1_c2_idx], select_idx[2][pd1_c2_idx]] = iset+1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">abc_2</span> <span class="o">=</span> <span class="n">dip_norm</span><span class="p">[:,</span> <span class="n">iset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Points on plane</span>
            <span class="n">pd_2</span> <span class="o">=</span> <span class="n">abc_2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="n">iset</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">abc_2</span> <span class="o">*</span> <span class="n">abc_2</span><span class="p">))</span>  <span class="c1"># Distance to plane</span>
            <span class="n">inset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">pd_1</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pd_2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>                                   <span class="c1"># grid cell between planes</span>
            <span class="n">set_no</span><span class="p">[</span><span class="n">select_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">inset</span><span class="p">],</span> <span class="n">select_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">inset</span><span class="p">],</span> <span class="n">select_idx</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">inset</span><span class="p">]]</span> <span class="o">=</span> <span class="n">iset</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">set_no</span></div>


<span class="sd">&quot;&quot;&quot;--------------------------------------------------------------------------------------------------------------</span>
<span class="sd">Testing functions</span>
<span class="sd">--------------------------------------------------------------------------------------------------------------&quot;&quot;&quot;</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">param_file</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">param_file</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1">#channel_checker(param_file, &#39;meander_channel&#39;, no_extpar=5, dist=10000)</span>
        <span class="c1"># param_file = &#39;E:\\Repositories\\WP3_effects\\case_studies\\trough\\tr1\\tr1dip.ini&#39;</span>
        <span class="c1"># param_file = &#39;..\\testcases\\made.ini&#39;</span>
    <span class="n">run</span><span class="p">(</span><span class="n">param_file</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../methods.html">HyVR Computational methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../inout.html">HyVR inputs and outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example.html">HyVR Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../more.html">Extending HyVR</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">HyVR package</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">HYVR 0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017-2018, Jeremy Bennett.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>